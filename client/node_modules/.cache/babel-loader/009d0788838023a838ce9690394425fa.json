{"ast":null,"code":"\"use strict\";\n\nvar toArray = require('../../../toArray');\n\nvar getRelativePath = require('./getRelativePath');\n\nvar getFilesAndDirectoriesFromDirectory = require('./getFilesAndDirectoriesFromDirectory');\n\nmodule.exports = function webkitGetAsEntryApi(dataTransfer, logDropError) {\n  var files = [];\n  var rootPromises = [];\n  /**\n   * Returns a resolved promise, when :files array is enhanced\n   *\n   * @param {(FileSystemFileEntry|FileSystemDirectoryEntry)} entry\n   * @returns {Promise} - empty promise that resolves when :files is enhanced with a file\n   */\n\n  var createPromiseToAddFileOrParseDirectory = function createPromiseToAddFileOrParseDirectory(entry) {\n    return new Promise(function (resolve) {\n      // This is a base call\n      if (entry.isFile) {\n        // Creates a new File object which can be used to read the file.\n        entry.file(function (file) {\n          // eslint-disable-next-line no-param-reassign\n          file.relativePath = getRelativePath(entry);\n          files.push(file);\n          resolve();\n        }, // Make sure we resolve on error anyway, it's fine if only one file couldn't be read!\n        function (error) {\n          logDropError(error);\n          resolve();\n        }); // This is a recursive call\n      } else if (entry.isDirectory) {\n        var directoryReader = entry.createReader();\n        getFilesAndDirectoriesFromDirectory(directoryReader, [], logDropError, {\n          onSuccess: function onSuccess(entries) {\n            return resolve(Promise.all(entries.map(createPromiseToAddFileOrParseDirectory)));\n          }\n        });\n      }\n    });\n  }; // For each dropped item, - make sure it's a file/directory, and start deepening in!\n\n\n  toArray(dataTransfer.items).forEach(function (item) {\n    var entry = item.webkitGetAsEntry(); // :entry can be null when we drop the url e.g.\n\n    if (entry) {\n      rootPromises.push(createPromiseToAddFileOrParseDirectory(entry));\n    }\n  });\n  return Promise.all(rootPromises).then(function () {\n    return files;\n  });\n};","map":{"version":3,"sources":["/Users/albertshay/Desktop/silkroad/client/node_modules/@uppy/utils/lib/getDroppedFiles/utils/webkitGetAsEntryApi/index.js"],"names":["toArray","require","getRelativePath","getFilesAndDirectoriesFromDirectory","module","exports","webkitGetAsEntryApi","dataTransfer","logDropError","files","rootPromises","createPromiseToAddFileOrParseDirectory","entry","Promise","resolve","isFile","file","relativePath","push","error","isDirectory","directoryReader","createReader","onSuccess","entries","all","map","items","forEach","item","webkitGetAsEntry","then"],"mappings":"AAAA;;AAEA,IAAMA,OAAO,GAAGC,OAAO,CAAC,kBAAD,CAAvB;;AAEA,IAAMC,eAAe,GAAGD,OAAO,CAAC,mBAAD,CAA/B;;AAEA,IAAME,mCAAmC,GAAGF,OAAO,CAAC,uCAAD,CAAnD;;AAEAG,MAAM,CAACC,OAAP,GAAiB,SAASC,mBAAT,CAA6BC,YAA7B,EAA2CC,YAA3C,EAAyD;AACxE,MAAMC,KAAK,GAAG,EAAd;AACA,MAAMC,YAAY,GAAG,EAArB;AACA;AACF;AACA;AACA;AACA;AACA;;AAEE,MAAMC,sCAAsC,GAAG,SAAzCA,sCAAyC,CAAAC,KAAK;AAAA,WAAI,IAAIC,OAAJ,CAAY,UAAAC,OAAO,EAAI;AAC7E;AACA,UAAIF,KAAK,CAACG,MAAV,EAAkB;AAChB;AACAH,QAAAA,KAAK,CAACI,IAAN,CAAW,UAAAA,IAAI,EAAI;AACjB;AACAA,UAAAA,IAAI,CAACC,YAAL,GAAoBf,eAAe,CAACU,KAAD,CAAnC;AACAH,UAAAA,KAAK,CAACS,IAAN,CAAWF,IAAX;AACAF,UAAAA,OAAO;AACR,SALD,EAKG;AACH,kBAAAK,KAAK,EAAI;AACPX,UAAAA,YAAY,CAACW,KAAD,CAAZ;AACAL,UAAAA,OAAO;AACR,SATD,EAFgB,CAWZ;AACL,OAZD,MAYO,IAAIF,KAAK,CAACQ,WAAV,EAAuB;AAC5B,YAAMC,eAAe,GAAGT,KAAK,CAACU,YAAN,EAAxB;AACAnB,QAAAA,mCAAmC,CAACkB,eAAD,EAAkB,EAAlB,EAAsBb,YAAtB,EAAoC;AACrEe,UAAAA,SAAS,EAAE,mBAAAC,OAAO;AAAA,mBAAIV,OAAO,CAACD,OAAO,CAACY,GAAR,CAAYD,OAAO,CAACE,GAAR,CAAYf,sCAAZ,CAAZ,CAAD,CAAX;AAAA;AADmD,SAApC,CAAnC;AAGD;AACF,KApBuD,CAAJ;AAAA,GAApD,CAVwE,CA8BpE;;;AAGJX,EAAAA,OAAO,CAACO,YAAY,CAACoB,KAAd,CAAP,CAA4BC,OAA5B,CAAoC,UAAAC,IAAI,EAAI;AAC1C,QAAMjB,KAAK,GAAGiB,IAAI,CAACC,gBAAL,EAAd,CAD0C,CACH;;AAEvC,QAAIlB,KAAJ,EAAW;AACTF,MAAAA,YAAY,CAACQ,IAAb,CAAkBP,sCAAsC,CAACC,KAAD,CAAxD;AACD;AACF,GAND;AAOA,SAAOC,OAAO,CAACY,GAAR,CAAYf,YAAZ,EAA0BqB,IAA1B,CAA+B;AAAA,WAAMtB,KAAN;AAAA,GAA/B,CAAP;AACD,CAzCD","sourcesContent":["\"use strict\";\n\nconst toArray = require('../../../toArray');\n\nconst getRelativePath = require('./getRelativePath');\n\nconst getFilesAndDirectoriesFromDirectory = require('./getFilesAndDirectoriesFromDirectory');\n\nmodule.exports = function webkitGetAsEntryApi(dataTransfer, logDropError) {\n  const files = [];\n  const rootPromises = [];\n  /**\n   * Returns a resolved promise, when :files array is enhanced\n   *\n   * @param {(FileSystemFileEntry|FileSystemDirectoryEntry)} entry\n   * @returns {Promise} - empty promise that resolves when :files is enhanced with a file\n   */\n\n  const createPromiseToAddFileOrParseDirectory = entry => new Promise(resolve => {\n    // This is a base call\n    if (entry.isFile) {\n      // Creates a new File object which can be used to read the file.\n      entry.file(file => {\n        // eslint-disable-next-line no-param-reassign\n        file.relativePath = getRelativePath(entry);\n        files.push(file);\n        resolve();\n      }, // Make sure we resolve on error anyway, it's fine if only one file couldn't be read!\n      error => {\n        logDropError(error);\n        resolve();\n      }); // This is a recursive call\n    } else if (entry.isDirectory) {\n      const directoryReader = entry.createReader();\n      getFilesAndDirectoriesFromDirectory(directoryReader, [], logDropError, {\n        onSuccess: entries => resolve(Promise.all(entries.map(createPromiseToAddFileOrParseDirectory)))\n      });\n    }\n  }); // For each dropped item, - make sure it's a file/directory, and start deepening in!\n\n\n  toArray(dataTransfer.items).forEach(item => {\n    const entry = item.webkitGetAsEntry(); // :entry can be null when we drop the url e.g.\n\n    if (entry) {\n      rootPromises.push(createPromiseToAddFileOrParseDirectory(entry));\n    }\n  });\n  return Promise.all(rootPromises).then(() => files);\n};"]},"metadata":{},"sourceType":"script"}