{"ast":null,"code":"/* eslint-disable */\n\n/**\n * @source https://github.com/developit/preact-transition-group\n */\n'use strict';\n\nconst {\n  Component,\n  cloneElement,\n  h,\n  toChildArray\n} = require('preact');\n\nfunction assign(obj, props) {\n  return Object.assign(obj, props);\n}\n\nfunction getKey(vnode, fallback) {\n  var _vnode$key;\n\n  return (_vnode$key = vnode == null ? void 0 : vnode.key) != null ? _vnode$key : fallback;\n}\n\nfunction linkRef(component, name) {\n  const cache = component._ptgLinkedRefs || (component._ptgLinkedRefs = {});\n  return cache[name] || (cache[name] = c => {\n    component.refs[name] = c;\n  });\n}\n\nfunction getChildMapping(children) {\n  const out = {};\n\n  for (let i = 0; i < children.length; i++) {\n    if (children[i] != null) {\n      const key = getKey(children[i], i.toString(36));\n      out[key] = children[i];\n    }\n  }\n\n  return out;\n}\n\nfunction mergeChildMappings(prev, next) {\n  prev = prev || {};\n  next = next || {};\n\n  const getValueForKey = key => next.hasOwnProperty(key) ? next[key] : prev[key]; // For each key of `next`, the list of keys to insert before that key in\n  // the combined list\n\n\n  const nextKeysPending = {};\n  let pendingKeys = [];\n\n  for (const prevKey in prev) {\n    if (next.hasOwnProperty(prevKey)) {\n      if (pendingKeys.length) {\n        nextKeysPending[prevKey] = pendingKeys;\n        pendingKeys = [];\n      }\n    } else {\n      pendingKeys.push(prevKey);\n    }\n  }\n\n  const childMapping = {};\n\n  for (const nextKey in next) {\n    if (nextKeysPending.hasOwnProperty(nextKey)) {\n      for (let i = 0; i < nextKeysPending[nextKey].length; i++) {\n        const pendingNextKey = nextKeysPending[nextKey][i];\n        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);\n      }\n    }\n\n    childMapping[nextKey] = getValueForKey(nextKey);\n  } // Finally, add the keys which didn't appear before any key in `next`\n\n\n  for (let i = 0; i < pendingKeys.length; i++) {\n    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);\n  }\n\n  return childMapping;\n}\n\nconst identity = i => i;\n\nclass TransitionGroup extends Component {\n  constructor(props, context) {\n    super(props, context);\n    this.refs = {};\n    this.state = {\n      children: getChildMapping(toChildArray(toChildArray(this.props.children)) || [])\n    };\n    this.performAppear = this.performAppear.bind(this);\n    this.performEnter = this.performEnter.bind(this);\n    this.performLeave = this.performLeave.bind(this);\n  }\n\n  componentWillMount() {\n    this.currentlyTransitioningKeys = {};\n    this.keysToAbortLeave = [];\n    this.keysToEnter = [];\n    this.keysToLeave = [];\n  }\n\n  componentDidMount() {\n    const initialChildMapping = this.state.children;\n\n    for (const key in initialChildMapping) {\n      if (initialChildMapping[key]) {\n        // this.performAppear(getKey(initialChildMapping[key], key));\n        this.performAppear(key);\n      }\n    }\n  }\n\n  componentWillReceiveProps(nextProps) {\n    const nextChildMapping = getChildMapping(toChildArray(nextProps.children) || []);\n    const prevChildMapping = this.state.children;\n    this.setState(prevState => ({\n      children: mergeChildMappings(prevState.children, nextChildMapping)\n    }));\n    let key;\n\n    for (key in nextChildMapping) {\n      if (nextChildMapping.hasOwnProperty(key)) {\n        const hasPrev = prevChildMapping && prevChildMapping.hasOwnProperty(key); // We should re-enter the component and abort its leave function\n\n        if (nextChildMapping[key] && hasPrev && this.currentlyTransitioningKeys[key]) {\n          this.keysToEnter.push(key);\n          this.keysToAbortLeave.push(key);\n        } else if (nextChildMapping[key] && !hasPrev && !this.currentlyTransitioningKeys[key]) {\n          this.keysToEnter.push(key);\n        }\n      }\n    }\n\n    for (key in prevChildMapping) {\n      if (prevChildMapping.hasOwnProperty(key)) {\n        const hasNext = nextChildMapping && nextChildMapping.hasOwnProperty(key);\n\n        if (prevChildMapping[key] && !hasNext && !this.currentlyTransitioningKeys[key]) {\n          this.keysToLeave.push(key);\n        }\n      }\n    }\n  }\n\n  componentDidUpdate() {\n    const {\n      keysToEnter\n    } = this;\n    this.keysToEnter = [];\n    keysToEnter.forEach(this.performEnter);\n    const {\n      keysToLeave\n    } = this;\n    this.keysToLeave = [];\n    keysToLeave.forEach(this.performLeave);\n  }\n\n  _finishAbort(key) {\n    const idx = this.keysToAbortLeave.indexOf(key);\n\n    if (idx !== -1) {\n      this.keysToAbortLeave.splice(idx, 1);\n    }\n  }\n\n  performAppear(key) {\n    this.currentlyTransitioningKeys[key] = true;\n    const component = this.refs[key];\n\n    if (component.componentWillAppear) {\n      component.componentWillAppear(this._handleDoneAppearing.bind(this, key));\n    } else {\n      this._handleDoneAppearing(key);\n    }\n  }\n\n  _handleDoneAppearing(key) {\n    const component = this.refs[key];\n\n    if (component.componentDidAppear) {\n      component.componentDidAppear();\n    }\n\n    delete this.currentlyTransitioningKeys[key];\n\n    this._finishAbort(key);\n\n    const currentChildMapping = getChildMapping(toChildArray(this.props.children) || []);\n\n    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {\n      // This was removed before it had fully appeared. Remove it.\n      this.performLeave(key);\n    }\n  }\n\n  performEnter(key) {\n    this.currentlyTransitioningKeys[key] = true;\n    const component = this.refs[key];\n\n    if (component.componentWillEnter) {\n      component.componentWillEnter(this._handleDoneEntering.bind(this, key));\n    } else {\n      this._handleDoneEntering(key);\n    }\n  }\n\n  _handleDoneEntering(key) {\n    const component = this.refs[key];\n\n    if (component.componentDidEnter) {\n      component.componentDidEnter();\n    }\n\n    delete this.currentlyTransitioningKeys[key];\n\n    this._finishAbort(key);\n\n    const currentChildMapping = getChildMapping(toChildArray(this.props.children) || []);\n\n    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {\n      // This was removed before it had fully entered. Remove it.\n      this.performLeave(key);\n    }\n  }\n\n  performLeave(key) {\n    // If we should immediately abort this leave function,\n    // don't run the leave transition at all.\n    const idx = this.keysToAbortLeave.indexOf(key);\n\n    if (idx !== -1) {\n      return;\n    }\n\n    this.currentlyTransitioningKeys[key] = true;\n    const component = this.refs[key];\n\n    if (component.componentWillLeave) {\n      component.componentWillLeave(this._handleDoneLeaving.bind(this, key));\n    } else {\n      // Note that this is somewhat dangerous b/c it calls setState()\n      // again, effectively mutating the component before all the work\n      // is done.\n      this._handleDoneLeaving(key);\n    }\n  }\n\n  _handleDoneLeaving(key) {\n    // If we should immediately abort the leave,\n    // then skip this altogether\n    const idx = this.keysToAbortLeave.indexOf(key);\n\n    if (idx !== -1) {\n      return;\n    }\n\n    const component = this.refs[key];\n\n    if (component.componentDidLeave) {\n      component.componentDidLeave();\n    }\n\n    delete this.currentlyTransitioningKeys[key];\n    const currentChildMapping = getChildMapping(toChildArray(this.props.children) || []);\n\n    if (currentChildMapping && currentChildMapping.hasOwnProperty(key)) {\n      // This entered again before it fully left. Add it again.\n      this.performEnter(key);\n    } else {\n      const children = assign({}, this.state.children);\n      delete children[key];\n      this.setState({\n        children\n      });\n    }\n  }\n\n  render({\n    childFactory,\n    transitionLeave,\n    transitionName,\n    transitionAppear,\n    transitionEnter,\n    transitionLeaveTimeout,\n    transitionEnterTimeout,\n    transitionAppearTimeout,\n    component,\n    ...props\n  }, {\n    children\n  }) {\n    // TODO: we could get rid of the need for the wrapper node\n    // by cloning a single child\n    const childrenToRender = [];\n\n    for (const key in children) {\n      if (children.hasOwnProperty(key)) {\n        const child = children[key];\n\n        if (child) {\n          const ref = linkRef(this, key),\n                el = cloneElement(childFactory(child), {\n            ref,\n            key\n          });\n          childrenToRender.push(el);\n        }\n      }\n    }\n\n    return h(component, props, childrenToRender);\n  }\n\n}\n\nTransitionGroup.defaultProps = {\n  component: 'span',\n  childFactory: identity\n};\nmodule.exports = TransitionGroup;","map":{"version":3,"sources":["/Users/albertshay/Desktop/silkroad/client/node_modules/@uppy/informer/lib/TransitionGroup.js"],"names":["Component","cloneElement","h","toChildArray","require","assign","obj","props","Object","getKey","vnode","fallback","_vnode$key","key","linkRef","component","name","cache","_ptgLinkedRefs","c","refs","getChildMapping","children","out","i","length","toString","mergeChildMappings","prev","next","getValueForKey","hasOwnProperty","nextKeysPending","pendingKeys","prevKey","push","childMapping","nextKey","pendingNextKey","identity","TransitionGroup","constructor","context","state","performAppear","bind","performEnter","performLeave","componentWillMount","currentlyTransitioningKeys","keysToAbortLeave","keysToEnter","keysToLeave","componentDidMount","initialChildMapping","componentWillReceiveProps","nextProps","nextChildMapping","prevChildMapping","setState","prevState","hasPrev","hasNext","componentDidUpdate","forEach","_finishAbort","idx","indexOf","splice","componentWillAppear","_handleDoneAppearing","componentDidAppear","currentChildMapping","componentWillEnter","_handleDoneEntering","componentDidEnter","componentWillLeave","_handleDoneLeaving","componentDidLeave","render","childFactory","transitionLeave","transitionName","transitionAppear","transitionEnter","transitionLeaveTimeout","transitionEnterTimeout","transitionAppearTimeout","childrenToRender","child","ref","el","defaultProps","module","exports"],"mappings":"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","sourcesContent":["/* eslint-disable */\n\n/**\n * @source https://github.com/developit/preact-transition-group\n */\n'use strict';\n\nconst {\n  Component,\n  cloneElement,\n  h,\n  toChildArray\n} = require('preact');\n\nfunction assign(obj, props) {\n  return Object.assign(obj, props);\n}\n\nfunction getKey(vnode, fallback) {\n  var _vnode$key;\n\n  return (_vnode$key = vnode == null ? void 0 : vnode.key) != null ? _vnode$key : fallback;\n}\n\nfunction linkRef(component, name) {\n  const cache = component._ptgLinkedRefs || (component._ptgLinkedRefs = {});\n  return cache[name] || (cache[name] = c => {\n    component.refs[name] = c;\n  });\n}\n\nfunction getChildMapping(children) {\n  const out = {};\n\n  for (let i = 0; i < children.length; i++) {\n    if (children[i] != null) {\n      const key = getKey(children[i], i.toString(36));\n      out[key] = children[i];\n    }\n  }\n\n  return out;\n}\n\nfunction mergeChildMappings(prev, next) {\n  prev = prev || {};\n  next = next || {};\n\n  const getValueForKey = key => next.hasOwnProperty(key) ? next[key] : prev[key]; // For each key of `next`, the list of keys to insert before that key in\n  // the combined list\n\n\n  const nextKeysPending = {};\n  let pendingKeys = [];\n\n  for (const prevKey in prev) {\n    if (next.hasOwnProperty(prevKey)) {\n      if (pendingKeys.length) {\n        nextKeysPending[prevKey] = pendingKeys;\n        pendingKeys = [];\n      }\n    } else {\n      pendingKeys.push(prevKey);\n    }\n  }\n\n  const childMapping = {};\n\n  for (const nextKey in next) {\n    if (nextKeysPending.hasOwnProperty(nextKey)) {\n      for (let i = 0; i < nextKeysPending[nextKey].length; i++) {\n        const pendingNextKey = nextKeysPending[nextKey][i];\n        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);\n      }\n    }\n\n    childMapping[nextKey] = getValueForKey(nextKey);\n  } // Finally, add the keys which didn't appear before any key in `next`\n\n\n  for (let i = 0; i < pendingKeys.length; i++) {\n    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);\n  }\n\n  return childMapping;\n}\n\nconst identity = i => i;\n\nclass TransitionGroup extends Component {\n  constructor(props, context) {\n    super(props, context);\n    this.refs = {};\n    this.state = {\n      children: getChildMapping(toChildArray(toChildArray(this.props.children)) || [])\n    };\n    this.performAppear = this.performAppear.bind(this);\n    this.performEnter = this.performEnter.bind(this);\n    this.performLeave = this.performLeave.bind(this);\n  }\n\n  componentWillMount() {\n    this.currentlyTransitioningKeys = {};\n    this.keysToAbortLeave = [];\n    this.keysToEnter = [];\n    this.keysToLeave = [];\n  }\n\n  componentDidMount() {\n    const initialChildMapping = this.state.children;\n\n    for (const key in initialChildMapping) {\n      if (initialChildMapping[key]) {\n        // this.performAppear(getKey(initialChildMapping[key], key));\n        this.performAppear(key);\n      }\n    }\n  }\n\n  componentWillReceiveProps(nextProps) {\n    const nextChildMapping = getChildMapping(toChildArray(nextProps.children) || []);\n    const prevChildMapping = this.state.children;\n    this.setState(prevState => ({\n      children: mergeChildMappings(prevState.children, nextChildMapping)\n    }));\n    let key;\n\n    for (key in nextChildMapping) {\n      if (nextChildMapping.hasOwnProperty(key)) {\n        const hasPrev = prevChildMapping && prevChildMapping.hasOwnProperty(key); // We should re-enter the component and abort its leave function\n\n        if (nextChildMapping[key] && hasPrev && this.currentlyTransitioningKeys[key]) {\n          this.keysToEnter.push(key);\n          this.keysToAbortLeave.push(key);\n        } else if (nextChildMapping[key] && !hasPrev && !this.currentlyTransitioningKeys[key]) {\n          this.keysToEnter.push(key);\n        }\n      }\n    }\n\n    for (key in prevChildMapping) {\n      if (prevChildMapping.hasOwnProperty(key)) {\n        const hasNext = nextChildMapping && nextChildMapping.hasOwnProperty(key);\n\n        if (prevChildMapping[key] && !hasNext && !this.currentlyTransitioningKeys[key]) {\n          this.keysToLeave.push(key);\n        }\n      }\n    }\n  }\n\n  componentDidUpdate() {\n    const {\n      keysToEnter\n    } = this;\n    this.keysToEnter = [];\n    keysToEnter.forEach(this.performEnter);\n    const {\n      keysToLeave\n    } = this;\n    this.keysToLeave = [];\n    keysToLeave.forEach(this.performLeave);\n  }\n\n  _finishAbort(key) {\n    const idx = this.keysToAbortLeave.indexOf(key);\n\n    if (idx !== -1) {\n      this.keysToAbortLeave.splice(idx, 1);\n    }\n  }\n\n  performAppear(key) {\n    this.currentlyTransitioningKeys[key] = true;\n    const component = this.refs[key];\n\n    if (component.componentWillAppear) {\n      component.componentWillAppear(this._handleDoneAppearing.bind(this, key));\n    } else {\n      this._handleDoneAppearing(key);\n    }\n  }\n\n  _handleDoneAppearing(key) {\n    const component = this.refs[key];\n\n    if (component.componentDidAppear) {\n      component.componentDidAppear();\n    }\n\n    delete this.currentlyTransitioningKeys[key];\n\n    this._finishAbort(key);\n\n    const currentChildMapping = getChildMapping(toChildArray(this.props.children) || []);\n\n    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {\n      // This was removed before it had fully appeared. Remove it.\n      this.performLeave(key);\n    }\n  }\n\n  performEnter(key) {\n    this.currentlyTransitioningKeys[key] = true;\n    const component = this.refs[key];\n\n    if (component.componentWillEnter) {\n      component.componentWillEnter(this._handleDoneEntering.bind(this, key));\n    } else {\n      this._handleDoneEntering(key);\n    }\n  }\n\n  _handleDoneEntering(key) {\n    const component = this.refs[key];\n\n    if (component.componentDidEnter) {\n      component.componentDidEnter();\n    }\n\n    delete this.currentlyTransitioningKeys[key];\n\n    this._finishAbort(key);\n\n    const currentChildMapping = getChildMapping(toChildArray(this.props.children) || []);\n\n    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {\n      // This was removed before it had fully entered. Remove it.\n      this.performLeave(key);\n    }\n  }\n\n  performLeave(key) {\n    // If we should immediately abort this leave function,\n    // don't run the leave transition at all.\n    const idx = this.keysToAbortLeave.indexOf(key);\n\n    if (idx !== -1) {\n      return;\n    }\n\n    this.currentlyTransitioningKeys[key] = true;\n    const component = this.refs[key];\n\n    if (component.componentWillLeave) {\n      component.componentWillLeave(this._handleDoneLeaving.bind(this, key));\n    } else {\n      // Note that this is somewhat dangerous b/c it calls setState()\n      // again, effectively mutating the component before all the work\n      // is done.\n      this._handleDoneLeaving(key);\n    }\n  }\n\n  _handleDoneLeaving(key) {\n    // If we should immediately abort the leave,\n    // then skip this altogether\n    const idx = this.keysToAbortLeave.indexOf(key);\n\n    if (idx !== -1) {\n      return;\n    }\n\n    const component = this.refs[key];\n\n    if (component.componentDidLeave) {\n      component.componentDidLeave();\n    }\n\n    delete this.currentlyTransitioningKeys[key];\n    const currentChildMapping = getChildMapping(toChildArray(this.props.children) || []);\n\n    if (currentChildMapping && currentChildMapping.hasOwnProperty(key)) {\n      // This entered again before it fully left. Add it again.\n      this.performEnter(key);\n    } else {\n      const children = assign({}, this.state.children);\n      delete children[key];\n      this.setState({\n        children\n      });\n    }\n  }\n\n  render({\n    childFactory,\n    transitionLeave,\n    transitionName,\n    transitionAppear,\n    transitionEnter,\n    transitionLeaveTimeout,\n    transitionEnterTimeout,\n    transitionAppearTimeout,\n    component,\n    ...props\n  }, {\n    children\n  }) {\n    // TODO: we could get rid of the need for the wrapper node\n    // by cloning a single child\n    const childrenToRender = [];\n\n    for (const key in children) {\n      if (children.hasOwnProperty(key)) {\n        const child = children[key];\n\n        if (child) {\n          const ref = linkRef(this, key),\n                el = cloneElement(childFactory(child), {\n            ref,\n            key\n          });\n          childrenToRender.push(el);\n        }\n      }\n    }\n\n    return h(component, props, childrenToRender);\n  }\n\n}\n\nTransitionGroup.defaultProps = {\n  component: 'span',\n  childFactory: identity\n};\nmodule.exports = TransitionGroup;"]},"metadata":{},"sourceType":"script"}