{"ast":null,"code":"\"use strict\";\n\nvar _class, _enableMirror, _temp;\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _classPrivateFieldLooseBase(receiver, privateKey) {\n  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n    throw new TypeError(\"attempted to use private field on non-instance\");\n  }\n\n  return receiver;\n}\n\nvar id = 0;\n\nfunction _classPrivateFieldLooseKey(name) {\n  return \"__private_\" + id++ + \"_\" + name;\n}\n\nconst {\n  h\n} = require('preact');\n\nconst {\n  UIPlugin\n} = require('@uppy/core');\n\nconst getFileTypeExtension = require('@uppy/utils/lib/getFileTypeExtension');\n\nconst mimeTypes = require('@uppy/utils/lib/mimeTypes');\n\nconst canvasToBlob = require('@uppy/utils/lib/canvasToBlob');\n\nconst supportsMediaRecorder = require('./supportsMediaRecorder');\n\nconst CameraIcon = require('./CameraIcon');\n\nconst CameraScreen = require('./CameraScreen');\n\nconst PermissionsScreen = require('./PermissionsScreen');\n/**\n * Normalize a MIME type or file extension into a MIME type.\n *\n * @param {string} fileType - MIME type or a file extension prefixed with `.`.\n * @returns {string|undefined} The MIME type or `undefined` if the fileType is an extension and is not known.\n */\n\n\nfunction toMimeType(fileType) {\n  if (fileType[0] === '.') {\n    return mimeTypes[fileType.slice(1)];\n  }\n\n  return fileType;\n}\n/**\n * Is this MIME type a video?\n *\n * @param {string} mimeType - MIME type.\n * @returns {boolean}\n */\n\n\nfunction isVideoMimeType(mimeType) {\n  return /^video\\/[^*]+$/.test(mimeType);\n}\n/**\n * Is this MIME type an image?\n *\n * @param {string} mimeType - MIME type.\n * @returns {boolean}\n */\n\n\nfunction isImageMimeType(mimeType) {\n  return /^image\\/[^*]+$/.test(mimeType);\n}\n\nfunction getMediaDevices() {\n  // bug in the compatibility data\n  // eslint-disable-next-line compat/compat\n  return navigator.mediaDevices;\n}\n/**\n * Webcam\n */\n\n\nmodule.exports = (_temp = (_enableMirror = /*#__PURE__*/_classPrivateFieldLooseKey(\"enableMirror\"), _class = class Webcam extends UIPlugin {\n  // eslint-disable-next-line global-require\n  // enableMirror is used to toggle mirroring, for instance when discarding the video,\n  // while `opts.mirror` is used to remember the initial user setting\n  constructor(uppy, opts) {\n    super(uppy, opts);\n    Object.defineProperty(this, _enableMirror, {\n      writable: true,\n      value: void 0\n    });\n    this.mediaDevices = getMediaDevices();\n    this.supportsUserMedia = !!this.mediaDevices; // eslint-disable-next-line no-restricted-globals\n\n    this.protocol = location.protocol.match(/https/i) ? 'https' : 'http';\n    this.id = this.opts.id || 'Webcam';\n    this.type = 'acquirer';\n    this.capturedMediaFile = null;\n\n    this.icon = () => h(\"svg\", {\n      \"aria-hidden\": \"true\",\n      focusable: \"false\",\n      width: \"32\",\n      height: \"32\",\n      viewBox: \"0 0 32 32\"\n    }, h(\"g\", {\n      fill: \"none\",\n      fillRule: \"evenodd\"\n    }, h(\"rect\", {\n      className: \"uppy-ProviderIconBg\",\n      fill: \"#03BFEF\",\n      width: \"32\",\n      height: \"32\",\n      rx: \"16\"\n    }), h(\"path\", {\n      d: \"M22 11c1.133 0 2 .867 2 2v7.333c0 1.134-.867 2-2 2H10c-1.133 0-2-.866-2-2V13c0-1.133.867-2 2-2h2.333l1.134-1.733C13.6 9.133 13.8 9 14 9h4c.2 0 .4.133.533.267L19.667 11H22zm-6 1.533a3.764 3.764 0 0 0-3.8 3.8c0 2.129 1.672 3.801 3.8 3.801s3.8-1.672 3.8-3.8c0-2.13-1.672-3.801-3.8-3.801zm0 6.261c-1.395 0-2.46-1.066-2.46-2.46 0-1.395 1.065-2.461 2.46-2.461s2.46 1.066 2.46 2.46c0 1.395-1.065 2.461-2.46 2.461z\",\n      fill: \"#FFF\",\n      fillRule: \"nonzero\"\n    })));\n\n    this.defaultLocale = {\n      strings: {\n        pluginNameCamera: 'Camera',\n        smile: 'Smile!',\n        takePicture: 'Take a picture',\n        startRecording: 'Begin video recording',\n        stopRecording: 'Stop video recording',\n        allowAccessTitle: 'Please allow access to your camera',\n        allowAccessDescription: 'In order to take pictures or record video with your camera, please allow camera access for this site.',\n        noCameraTitle: 'Camera Not Available',\n        noCameraDescription: 'In order to take pictures or record video, please connect a camera device',\n        recordingStoppedMaxSize: 'Recording stopped because the file size is about to exceed the limit',\n        recordingLength: 'Recording length %{recording_length}',\n        submitRecordedFile: 'Submit recorded file',\n        discardRecordedFile: 'Discard recorded file'\n      }\n    }; // set default options\n\n    const defaultOptions = {\n      onBeforeSnapshot: () => Promise.resolve(),\n      countdown: false,\n      modes: ['video-audio', 'video-only', 'audio-only', 'picture'],\n      mirror: true,\n      showVideoSourceDropdown: false,\n      facingMode: 'user',\n      preferredImageMimeType: null,\n      preferredVideoMimeType: null,\n      showRecordingLength: false\n    };\n    this.opts = { ...defaultOptions,\n      ...opts\n    };\n    this.i18nInit();\n    this.title = this.i18n('pluginNameCamera');\n    _classPrivateFieldLooseBase(this, _enableMirror)[_enableMirror] = this.opts.mirror;\n    this.install = this.install.bind(this);\n    this.setPluginState = this.setPluginState.bind(this);\n    this.render = this.render.bind(this); // Camera controls\n\n    this.start = this.start.bind(this);\n    this.stop = this.stop.bind(this);\n    this.takeSnapshot = this.takeSnapshot.bind(this);\n    this.startRecording = this.startRecording.bind(this);\n    this.stopRecording = this.stopRecording.bind(this);\n    this.discardRecordedVideo = this.discardRecordedVideo.bind(this);\n    this.submit = this.submit.bind(this);\n    this.oneTwoThreeSmile = this.oneTwoThreeSmile.bind(this);\n    this.focus = this.focus.bind(this);\n    this.changeVideoSource = this.changeVideoSource.bind(this);\n    this.webcamActive = false;\n\n    if (this.opts.countdown) {\n      this.opts.onBeforeSnapshot = this.oneTwoThreeSmile;\n    }\n\n    this.setPluginState({\n      hasCamera: false,\n      cameraReady: false,\n      cameraError: null,\n      recordingLengthSeconds: 0,\n      videoSources: [],\n      currentDeviceId: null\n    });\n  }\n\n  setOptions(newOpts) {\n    super.setOptions({ ...newOpts,\n      videoConstraints: { // May be undefined but ... handles that\n        ...this.opts.videoConstraints,\n        ...(newOpts == null ? void 0 : newOpts.videoConstraints)\n      }\n    });\n  }\n\n  hasCameraCheck() {\n    if (!this.mediaDevices) {\n      return Promise.resolve(false);\n    }\n\n    return this.mediaDevices.enumerateDevices().then(devices => {\n      return devices.some(device => device.kind === 'videoinput');\n    });\n  }\n\n  isAudioOnly() {\n    return this.opts.modes.length === 1 && this.opts.modes[0] === 'audio-only';\n  }\n\n  getConstraints(deviceId = null) {\n    const acceptsAudio = this.opts.modes.indexOf('video-audio') !== -1 || this.opts.modes.indexOf('audio-only') !== -1;\n    const acceptsVideo = !this.isAudioOnly() && (this.opts.modes.indexOf('video-audio') !== -1 || this.opts.modes.indexOf('video-only') !== -1 || this.opts.modes.indexOf('picture') !== -1);\n    const videoConstraints = { ...(this.opts.videoConstraints || {\n        facingMode: this.opts.facingMode\n      }),\n      // facingMode takes precedence over deviceId, and not needed\n      // when specific device is selected\n      ...(deviceId ? {\n        deviceId,\n        facingMode: null\n      } : {})\n    };\n    return {\n      audio: acceptsAudio,\n      video: acceptsVideo ? videoConstraints : false\n    };\n  } // eslint-disable-next-line consistent-return\n\n\n  start(options = null) {\n    if (!this.supportsUserMedia) {\n      return Promise.reject(new Error('Webcam access not supported'));\n    }\n\n    this.webcamActive = true;\n\n    if (this.opts.mirror) {\n      _classPrivateFieldLooseBase(this, _enableMirror)[_enableMirror] = true;\n    }\n\n    const constraints = this.getConstraints(options && options.deviceId ? options.deviceId : null);\n    this.hasCameraCheck().then(hasCamera => {\n      this.setPluginState({\n        hasCamera\n      }); // ask user for access to their camera\n\n      return this.mediaDevices.getUserMedia(constraints).then(stream => {\n        this.stream = stream;\n        let currentDeviceId = null;\n        const tracks = this.isAudioOnly() ? stream.getAudioTracks() : stream.getVideoTracks();\n\n        if (!options || !options.deviceId) {\n          currentDeviceId = tracks[0].getSettings().deviceId;\n        } else {\n          tracks.forEach(track => {\n            if (track.getSettings().deviceId === options.deviceId) {\n              currentDeviceId = track.getSettings().deviceId;\n            }\n          });\n        } // Update the sources now, so we can access the names.\n\n\n        this.updateVideoSources();\n        this.setPluginState({\n          currentDeviceId,\n          cameraReady: true\n        });\n      }).catch(err => {\n        this.setPluginState({\n          cameraReady: false,\n          cameraError: err\n        });\n        this.uppy.info(err.message, 'error');\n      });\n    });\n  }\n  /**\n   * @returns {object}\n   */\n\n\n  getMediaRecorderOptions() {\n    const options = {}; // Try to use the `opts.preferredVideoMimeType` or one of the `allowedFileTypes` for the recording.\n    // If the browser doesn't support it, we'll fall back to the browser default instead.\n    // Safari doesn't have the `isTypeSupported` API.\n\n    if (MediaRecorder.isTypeSupported) {\n      const {\n        restrictions\n      } = this.uppy.opts;\n      let preferredVideoMimeTypes = [];\n\n      if (this.opts.preferredVideoMimeType) {\n        preferredVideoMimeTypes = [this.opts.preferredVideoMimeType];\n      } else if (restrictions.allowedFileTypes) {\n        preferredVideoMimeTypes = restrictions.allowedFileTypes.map(toMimeType).filter(isVideoMimeType);\n      }\n\n      const filterSupportedTypes = candidateType => MediaRecorder.isTypeSupported(candidateType) && getFileTypeExtension(candidateType);\n\n      const acceptableMimeTypes = preferredVideoMimeTypes.filter(filterSupportedTypes);\n\n      if (acceptableMimeTypes.length > 0) {\n        // eslint-disable-next-line prefer-destructuring\n        options.mimeType = acceptableMimeTypes[0];\n      }\n    }\n\n    return options;\n  }\n\n  startRecording() {\n    // only used if supportsMediaRecorder() returned true\n    // eslint-disable-next-line compat/compat\n    this.recorder = new MediaRecorder(this.stream, this.getMediaRecorderOptions());\n    this.recordingChunks = [];\n    let stoppingBecauseOfMaxSize = false;\n    this.recorder.addEventListener('dataavailable', event => {\n      this.recordingChunks.push(event.data);\n      const {\n        restrictions\n      } = this.uppy.opts;\n\n      if (this.recordingChunks.length > 1 && restrictions.maxFileSize != null && !stoppingBecauseOfMaxSize) {\n        const totalSize = this.recordingChunks.reduce((acc, chunk) => acc + chunk.size, 0); // Exclude the initial chunk from the average size calculation because it is likely to be a very small outlier\n\n        const averageChunkSize = (totalSize - this.recordingChunks[0].size) / (this.recordingChunks.length - 1);\n        const expectedEndChunkSize = averageChunkSize * 3;\n        const maxSize = Math.max(0, restrictions.maxFileSize - expectedEndChunkSize);\n\n        if (totalSize > maxSize) {\n          stoppingBecauseOfMaxSize = true;\n          this.uppy.info(this.i18n('recordingStoppedMaxSize'), 'warning', 4000);\n          this.stopRecording();\n        }\n      }\n    }); // use a \"time slice\" of 500ms: ondataavailable will be called each 500ms\n    // smaller time slices mean we can more accurately check the max file size restriction\n\n    this.recorder.start(500);\n\n    if (this.opts.showRecordingLength) {\n      // Start the recordingLengthTimer if we are showing the recording length.\n      this.recordingLengthTimer = setInterval(() => {\n        const currentRecordingLength = this.getPluginState().recordingLengthSeconds;\n        this.setPluginState({\n          recordingLengthSeconds: currentRecordingLength + 1\n        });\n      }, 1000);\n    }\n\n    this.setPluginState({\n      isRecording: true\n    });\n  }\n\n  stopRecording() {\n    const stopped = new Promise(resolve => {\n      this.recorder.addEventListener('stop', () => {\n        resolve();\n      });\n      this.recorder.stop();\n\n      if (this.opts.showRecordingLength) {\n        // Stop the recordingLengthTimer if we are showing the recording length.\n        clearInterval(this.recordingLengthTimer);\n        this.setPluginState({\n          recordingLengthSeconds: 0\n        });\n      }\n    });\n    return stopped.then(() => {\n      this.setPluginState({\n        isRecording: false\n      });\n      return this.getVideo();\n    }).then(file => {\n      try {\n        this.capturedMediaFile = file; // create object url for capture result preview\n\n        this.setPluginState({\n          // eslint-disable-next-line compat/compat\n          recordedVideo: URL.createObjectURL(file.data)\n        });\n        _classPrivateFieldLooseBase(this, _enableMirror)[_enableMirror] = false;\n      } catch (err) {\n        // Logging the error, exept restrictions, which is handled in Core\n        if (!err.isRestriction) {\n          this.uppy.log(err);\n        }\n      }\n    }).then(() => {\n      this.recordingChunks = null;\n      this.recorder = null;\n    }, error => {\n      this.recordingChunks = null;\n      this.recorder = null;\n      throw error;\n    });\n  }\n\n  discardRecordedVideo() {\n    this.setPluginState({\n      recordedVideo: null\n    });\n\n    if (this.opts.mirror) {\n      _classPrivateFieldLooseBase(this, _enableMirror)[_enableMirror] = true;\n    }\n\n    this.capturedMediaFile = null;\n  }\n\n  submit() {\n    try {\n      if (this.capturedMediaFile) {\n        this.uppy.addFile(this.capturedMediaFile);\n      }\n    } catch (err) {\n      // Logging the error, exept restrictions, which is handled in Core\n      if (!err.isRestriction) {\n        this.uppy.log(err, 'error');\n      }\n    }\n  }\n\n  async stop() {\n    if (this.stream) {\n      const audioTracks = this.stream.getAudioTracks();\n      const videoTracks = this.stream.getVideoTracks();\n      audioTracks.concat(videoTracks).forEach(track => track.stop());\n    }\n\n    if (this.recorder) {\n      await new Promise(resolve => {\n        this.recorder.addEventListener('stop', resolve, {\n          once: true\n        });\n        this.recorder.stop();\n\n        if (this.opts.showRecordingLength) {\n          clearInterval(this.recordingLengthTimer);\n        }\n      });\n    }\n\n    this.recordingChunks = null;\n    this.recorder = null;\n    this.webcamActive = false;\n    this.stream = null;\n    this.setPluginState({\n      recordedVideo: null,\n      isRecording: false,\n      recordingLengthSeconds: 0\n    });\n  }\n\n  getVideoElement() {\n    return this.el.querySelector('.uppy-Webcam-video');\n  }\n\n  oneTwoThreeSmile() {\n    return new Promise((resolve, reject) => {\n      let count = this.opts.countdown; // eslint-disable-next-line consistent-return\n\n      const countDown = setInterval(() => {\n        if (!this.webcamActive) {\n          clearInterval(countDown);\n          this.captureInProgress = false;\n          return reject(new Error('Webcam is not active'));\n        }\n\n        if (count > 0) {\n          this.uppy.info(`${count}...`, 'warning', 800);\n          count--;\n        } else {\n          clearInterval(countDown);\n          this.uppy.info(this.i18n('smile'), 'success', 1500);\n          setTimeout(() => resolve(), 1500);\n        }\n      }, 1000);\n    });\n  }\n\n  takeSnapshot() {\n    if (this.captureInProgress) return;\n    this.captureInProgress = true;\n    this.opts.onBeforeSnapshot().catch(err => {\n      const message = typeof err === 'object' ? err.message : err;\n      this.uppy.info(message, 'error', 5000);\n      return Promise.reject(new Error(`onBeforeSnapshot: ${message}`));\n    }).then(() => {\n      return this.getImage();\n    }).then(tagFile => {\n      this.captureInProgress = false;\n\n      try {\n        this.uppy.addFile(tagFile);\n      } catch (err) {\n        // Logging the error, except restrictions, which is handled in Core\n        if (!err.isRestriction) {\n          this.uppy.log(err);\n        }\n      }\n    }, error => {\n      this.captureInProgress = false;\n      throw error;\n    });\n  }\n\n  getImage() {\n    const video = this.getVideoElement();\n\n    if (!video) {\n      return Promise.reject(new Error('No video element found, likely due to the Webcam tab being closed.'));\n    }\n\n    const width = video.videoWidth;\n    const height = video.videoHeight;\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext('2d');\n    ctx.drawImage(video, 0, 0);\n    const {\n      restrictions\n    } = this.uppy.opts;\n    let preferredImageMimeTypes = [];\n\n    if (this.opts.preferredImageMimeType) {\n      preferredImageMimeTypes = [this.opts.preferredImageMimeType];\n    } else if (restrictions.allowedFileTypes) {\n      preferredImageMimeTypes = restrictions.allowedFileTypes.map(toMimeType).filter(isImageMimeType);\n    }\n\n    const mimeType = preferredImageMimeTypes[0] || 'image/jpeg';\n    const ext = getFileTypeExtension(mimeType) || 'jpg';\n    const name = `cam-${Date.now()}.${ext}`;\n    return canvasToBlob(canvas, mimeType).then(blob => {\n      return {\n        source: this.id,\n        name,\n        data: new Blob([blob], {\n          type: mimeType\n        }),\n        type: mimeType\n      };\n    });\n  }\n\n  getVideo() {\n    // Sometimes in iOS Safari, Blobs (especially the first Blob in the recordingChunks Array)\n    // have empty 'type' attributes (e.g. '') so we need to find a Blob that has a defined 'type'\n    // attribute in order to determine the correct MIME type.\n    const mimeType = this.recordingChunks.find(blob => {\n      var _blob$type;\n\n      return ((_blob$type = blob.type) == null ? void 0 : _blob$type.length) > 0;\n    }).type;\n    const fileExtension = getFileTypeExtension(mimeType);\n\n    if (!fileExtension) {\n      return Promise.reject(new Error(`Could not retrieve recording: Unsupported media type \"${mimeType}\"`));\n    }\n\n    const name = `webcam-${Date.now()}.${fileExtension}`;\n    const blob = new Blob(this.recordingChunks, {\n      type: mimeType\n    });\n    const file = {\n      source: this.id,\n      name,\n      data: new Blob([blob], {\n        type: mimeType\n      }),\n      type: mimeType\n    };\n    return Promise.resolve(file);\n  }\n\n  focus() {\n    if (!this.opts.countdown) return;\n    setTimeout(() => {\n      this.uppy.info(this.i18n('smile'), 'success', 1500);\n    }, 1000);\n  }\n\n  changeVideoSource(deviceId) {\n    this.stop();\n    this.start({\n      deviceId\n    });\n  }\n\n  updateVideoSources() {\n    this.mediaDevices.enumerateDevices().then(devices => {\n      this.setPluginState({\n        videoSources: devices.filter(device => device.kind === 'videoinput')\n      });\n    });\n  }\n\n  render() {\n    if (!this.webcamActive) {\n      this.start();\n    }\n\n    const webcamState = this.getPluginState();\n\n    if (!webcamState.cameraReady || !webcamState.hasCamera) {\n      return h(PermissionsScreen, {\n        icon: CameraIcon,\n        i18n: this.i18n,\n        hasCamera: webcamState.hasCamera\n      });\n    }\n\n    return h(CameraScreen // eslint-disable-next-line react/jsx-props-no-spreading\n    , _extends({}, webcamState, {\n      onChangeVideoSource: this.changeVideoSource,\n      onSnapshot: this.takeSnapshot,\n      onStartRecording: this.startRecording,\n      onStopRecording: this.stopRecording,\n      onDiscardRecordedVideo: this.discardRecordedVideo,\n      onSubmit: this.submit,\n      onFocus: this.focus,\n      onStop: this.stop,\n      i18n: this.i18n,\n      modes: this.opts.modes,\n      showRecordingLength: this.opts.showRecordingLength,\n      showVideoSourceDropdown: this.opts.showVideoSourceDropdown,\n      supportsRecording: supportsMediaRecorder(),\n      recording: webcamState.isRecording,\n      mirror: _classPrivateFieldLooseBase(this, _enableMirror)[_enableMirror],\n      src: this.stream\n    }));\n  }\n\n  install() {\n    this.setPluginState({\n      cameraReady: false,\n      recordingLengthSeconds: 0\n    });\n    const {\n      target\n    } = this.opts;\n\n    if (target) {\n      this.mount(target, this);\n    }\n\n    if (this.mediaDevices) {\n      this.updateVideoSources();\n\n      this.mediaDevices.ondevicechange = () => {\n        this.updateVideoSources();\n\n        if (this.stream) {\n          let restartStream = true;\n          const {\n            videoSources,\n            currentDeviceId\n          } = this.getPluginState();\n          videoSources.forEach(videoSource => {\n            if (currentDeviceId === videoSource.deviceId) {\n              restartStream = false;\n            }\n          });\n\n          if (restartStream) {\n            this.stop();\n            this.start();\n          }\n        }\n      };\n    }\n  }\n\n  uninstall() {\n    this.stop();\n    this.unmount();\n  }\n\n  onUnmount() {\n    this.stop();\n  }\n\n}), _class.VERSION = \"2.0.4\", _temp);","map":{"version":3,"sources":["/Users/albertshay/Desktop/silkroad/client/node_modules/@uppy/webcam/lib/index.js"],"names":["_class","_enableMirror","_temp","_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","_classPrivateFieldLooseBase","receiver","privateKey","TypeError","id","_classPrivateFieldLooseKey","name","h","require","UIPlugin","getFileTypeExtension","mimeTypes","canvasToBlob","supportsMediaRecorder","CameraIcon","CameraScreen","PermissionsScreen","toMimeType","fileType","slice","isVideoMimeType","mimeType","test","isImageMimeType","getMediaDevices","navigator","mediaDevices","module","exports","Webcam","constructor","uppy","opts","defineProperty","writable","value","supportsUserMedia","protocol","location","match","type","capturedMediaFile","icon","focusable","width","height","viewBox","fill","fillRule","className","rx","d","defaultLocale","strings","pluginNameCamera","smile","takePicture","startRecording","stopRecording","allowAccessTitle","allowAccessDescription","noCameraTitle","noCameraDescription","recordingStoppedMaxSize","recordingLength","submitRecordedFile","discardRecordedFile","defaultOptions","onBeforeSnapshot","Promise","resolve","countdown","modes","mirror","showVideoSourceDropdown","facingMode","preferredImageMimeType","preferredVideoMimeType","showRecordingLength","i18nInit","title","i18n","install","bind","setPluginState","render","start","stop","takeSnapshot","discardRecordedVideo","submit","oneTwoThreeSmile","focus","changeVideoSource","webcamActive","hasCamera","cameraReady","cameraError","recordingLengthSeconds","videoSources","currentDeviceId","setOptions","newOpts","videoConstraints","hasCameraCheck","enumerateDevices","then","devices","some","device","kind","isAudioOnly","getConstraints","deviceId","acceptsAudio","indexOf","acceptsVideo","audio","video","options","reject","Error","constraints","getUserMedia","stream","tracks","getAudioTracks","getVideoTracks","getSettings","forEach","track","updateVideoSources","catch","err","info","message","getMediaRecorderOptions","MediaRecorder","isTypeSupported","restrictions","preferredVideoMimeTypes","allowedFileTypes","map","filter","filterSupportedTypes","candidateType","acceptableMimeTypes","recorder","recordingChunks","stoppingBecauseOfMaxSize","addEventListener","event","push","data","maxFileSize","totalSize","reduce","acc","chunk","size","averageChunkSize","expectedEndChunkSize","maxSize","Math","max","recordingLengthTimer","setInterval","currentRecordingLength","getPluginState","isRecording","stopped","clearInterval","getVideo","file","recordedVideo","URL","createObjectURL","isRestriction","log","error","addFile","audioTracks","videoTracks","concat","once","getVideoElement","el","querySelector","count","countDown","captureInProgress","setTimeout","getImage","tagFile","videoWidth","videoHeight","canvas","document","createElement","ctx","getContext","drawImage","preferredImageMimeTypes","ext","Date","now","blob","Blob","find","_blob$type","fileExtension","webcamState","onChangeVideoSource","onSnapshot","onStartRecording","onStopRecording","onDiscardRecordedVideo","onSubmit","onFocus","onStop","supportsRecording","recording","src","mount","ondevicechange","restartStream","videoSource","uninstall","unmount","onUnmount","VERSION"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _class, _enableMirror, _temp;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _classPrivateFieldLooseBase(receiver, privateKey) { if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) { throw new TypeError(\"attempted to use private field on non-instance\"); } return receiver; }\n\nvar id = 0;\n\nfunction _classPrivateFieldLooseKey(name) { return \"__private_\" + id++ + \"_\" + name; }\n\nconst {\n  h\n} = require('preact');\n\nconst {\n  UIPlugin\n} = require('@uppy/core');\n\nconst getFileTypeExtension = require('@uppy/utils/lib/getFileTypeExtension');\n\nconst mimeTypes = require('@uppy/utils/lib/mimeTypes');\n\nconst canvasToBlob = require('@uppy/utils/lib/canvasToBlob');\n\nconst supportsMediaRecorder = require('./supportsMediaRecorder');\n\nconst CameraIcon = require('./CameraIcon');\n\nconst CameraScreen = require('./CameraScreen');\n\nconst PermissionsScreen = require('./PermissionsScreen');\n/**\n * Normalize a MIME type or file extension into a MIME type.\n *\n * @param {string} fileType - MIME type or a file extension prefixed with `.`.\n * @returns {string|undefined} The MIME type or `undefined` if the fileType is an extension and is not known.\n */\n\n\nfunction toMimeType(fileType) {\n  if (fileType[0] === '.') {\n    return mimeTypes[fileType.slice(1)];\n  }\n\n  return fileType;\n}\n/**\n * Is this MIME type a video?\n *\n * @param {string} mimeType - MIME type.\n * @returns {boolean}\n */\n\n\nfunction isVideoMimeType(mimeType) {\n  return /^video\\/[^*]+$/.test(mimeType);\n}\n/**\n * Is this MIME type an image?\n *\n * @param {string} mimeType - MIME type.\n * @returns {boolean}\n */\n\n\nfunction isImageMimeType(mimeType) {\n  return /^image\\/[^*]+$/.test(mimeType);\n}\n\nfunction getMediaDevices() {\n  // bug in the compatibility data\n  // eslint-disable-next-line compat/compat\n  return navigator.mediaDevices;\n}\n/**\n * Webcam\n */\n\n\nmodule.exports = (_temp = (_enableMirror = /*#__PURE__*/_classPrivateFieldLooseKey(\"enableMirror\"), _class = class Webcam extends UIPlugin {\n  // eslint-disable-next-line global-require\n  // enableMirror is used to toggle mirroring, for instance when discarding the video,\n  // while `opts.mirror` is used to remember the initial user setting\n  constructor(uppy, opts) {\n    super(uppy, opts);\n    Object.defineProperty(this, _enableMirror, {\n      writable: true,\n      value: void 0\n    });\n    this.mediaDevices = getMediaDevices();\n    this.supportsUserMedia = !!this.mediaDevices; // eslint-disable-next-line no-restricted-globals\n\n    this.protocol = location.protocol.match(/https/i) ? 'https' : 'http';\n    this.id = this.opts.id || 'Webcam';\n    this.type = 'acquirer';\n    this.capturedMediaFile = null;\n\n    this.icon = () => h(\"svg\", {\n      \"aria-hidden\": \"true\",\n      focusable: \"false\",\n      width: \"32\",\n      height: \"32\",\n      viewBox: \"0 0 32 32\"\n    }, h(\"g\", {\n      fill: \"none\",\n      fillRule: \"evenodd\"\n    }, h(\"rect\", {\n      className: \"uppy-ProviderIconBg\",\n      fill: \"#03BFEF\",\n      width: \"32\",\n      height: \"32\",\n      rx: \"16\"\n    }), h(\"path\", {\n      d: \"M22 11c1.133 0 2 .867 2 2v7.333c0 1.134-.867 2-2 2H10c-1.133 0-2-.866-2-2V13c0-1.133.867-2 2-2h2.333l1.134-1.733C13.6 9.133 13.8 9 14 9h4c.2 0 .4.133.533.267L19.667 11H22zm-6 1.533a3.764 3.764 0 0 0-3.8 3.8c0 2.129 1.672 3.801 3.8 3.801s3.8-1.672 3.8-3.8c0-2.13-1.672-3.801-3.8-3.801zm0 6.261c-1.395 0-2.46-1.066-2.46-2.46 0-1.395 1.065-2.461 2.46-2.461s2.46 1.066 2.46 2.46c0 1.395-1.065 2.461-2.46 2.461z\",\n      fill: \"#FFF\",\n      fillRule: \"nonzero\"\n    })));\n\n    this.defaultLocale = {\n      strings: {\n        pluginNameCamera: 'Camera',\n        smile: 'Smile!',\n        takePicture: 'Take a picture',\n        startRecording: 'Begin video recording',\n        stopRecording: 'Stop video recording',\n        allowAccessTitle: 'Please allow access to your camera',\n        allowAccessDescription: 'In order to take pictures or record video with your camera, please allow camera access for this site.',\n        noCameraTitle: 'Camera Not Available',\n        noCameraDescription: 'In order to take pictures or record video, please connect a camera device',\n        recordingStoppedMaxSize: 'Recording stopped because the file size is about to exceed the limit',\n        recordingLength: 'Recording length %{recording_length}',\n        submitRecordedFile: 'Submit recorded file',\n        discardRecordedFile: 'Discard recorded file'\n      }\n    }; // set default options\n\n    const defaultOptions = {\n      onBeforeSnapshot: () => Promise.resolve(),\n      countdown: false,\n      modes: ['video-audio', 'video-only', 'audio-only', 'picture'],\n      mirror: true,\n      showVideoSourceDropdown: false,\n      facingMode: 'user',\n      preferredImageMimeType: null,\n      preferredVideoMimeType: null,\n      showRecordingLength: false\n    };\n    this.opts = { ...defaultOptions,\n      ...opts\n    };\n    this.i18nInit();\n    this.title = this.i18n('pluginNameCamera');\n    _classPrivateFieldLooseBase(this, _enableMirror)[_enableMirror] = this.opts.mirror;\n    this.install = this.install.bind(this);\n    this.setPluginState = this.setPluginState.bind(this);\n    this.render = this.render.bind(this); // Camera controls\n\n    this.start = this.start.bind(this);\n    this.stop = this.stop.bind(this);\n    this.takeSnapshot = this.takeSnapshot.bind(this);\n    this.startRecording = this.startRecording.bind(this);\n    this.stopRecording = this.stopRecording.bind(this);\n    this.discardRecordedVideo = this.discardRecordedVideo.bind(this);\n    this.submit = this.submit.bind(this);\n    this.oneTwoThreeSmile = this.oneTwoThreeSmile.bind(this);\n    this.focus = this.focus.bind(this);\n    this.changeVideoSource = this.changeVideoSource.bind(this);\n    this.webcamActive = false;\n\n    if (this.opts.countdown) {\n      this.opts.onBeforeSnapshot = this.oneTwoThreeSmile;\n    }\n\n    this.setPluginState({\n      hasCamera: false,\n      cameraReady: false,\n      cameraError: null,\n      recordingLengthSeconds: 0,\n      videoSources: [],\n      currentDeviceId: null\n    });\n  }\n\n  setOptions(newOpts) {\n    super.setOptions({ ...newOpts,\n      videoConstraints: { // May be undefined but ... handles that\n        ...this.opts.videoConstraints,\n        ...(newOpts == null ? void 0 : newOpts.videoConstraints)\n      }\n    });\n  }\n\n  hasCameraCheck() {\n    if (!this.mediaDevices) {\n      return Promise.resolve(false);\n    }\n\n    return this.mediaDevices.enumerateDevices().then(devices => {\n      return devices.some(device => device.kind === 'videoinput');\n    });\n  }\n\n  isAudioOnly() {\n    return this.opts.modes.length === 1 && this.opts.modes[0] === 'audio-only';\n  }\n\n  getConstraints(deviceId = null) {\n    const acceptsAudio = this.opts.modes.indexOf('video-audio') !== -1 || this.opts.modes.indexOf('audio-only') !== -1;\n    const acceptsVideo = !this.isAudioOnly() && (this.opts.modes.indexOf('video-audio') !== -1 || this.opts.modes.indexOf('video-only') !== -1 || this.opts.modes.indexOf('picture') !== -1);\n    const videoConstraints = { ...(this.opts.videoConstraints || {\n        facingMode: this.opts.facingMode\n      }),\n      // facingMode takes precedence over deviceId, and not needed\n      // when specific device is selected\n      ...(deviceId ? {\n        deviceId,\n        facingMode: null\n      } : {})\n    };\n    return {\n      audio: acceptsAudio,\n      video: acceptsVideo ? videoConstraints : false\n    };\n  } // eslint-disable-next-line consistent-return\n\n\n  start(options = null) {\n    if (!this.supportsUserMedia) {\n      return Promise.reject(new Error('Webcam access not supported'));\n    }\n\n    this.webcamActive = true;\n\n    if (this.opts.mirror) {\n      _classPrivateFieldLooseBase(this, _enableMirror)[_enableMirror] = true;\n    }\n\n    const constraints = this.getConstraints(options && options.deviceId ? options.deviceId : null);\n    this.hasCameraCheck().then(hasCamera => {\n      this.setPluginState({\n        hasCamera\n      }); // ask user for access to their camera\n\n      return this.mediaDevices.getUserMedia(constraints).then(stream => {\n        this.stream = stream;\n        let currentDeviceId = null;\n        const tracks = this.isAudioOnly() ? stream.getAudioTracks() : stream.getVideoTracks();\n\n        if (!options || !options.deviceId) {\n          currentDeviceId = tracks[0].getSettings().deviceId;\n        } else {\n          tracks.forEach(track => {\n            if (track.getSettings().deviceId === options.deviceId) {\n              currentDeviceId = track.getSettings().deviceId;\n            }\n          });\n        } // Update the sources now, so we can access the names.\n\n\n        this.updateVideoSources();\n        this.setPluginState({\n          currentDeviceId,\n          cameraReady: true\n        });\n      }).catch(err => {\n        this.setPluginState({\n          cameraReady: false,\n          cameraError: err\n        });\n        this.uppy.info(err.message, 'error');\n      });\n    });\n  }\n  /**\n   * @returns {object}\n   */\n\n\n  getMediaRecorderOptions() {\n    const options = {}; // Try to use the `opts.preferredVideoMimeType` or one of the `allowedFileTypes` for the recording.\n    // If the browser doesn't support it, we'll fall back to the browser default instead.\n    // Safari doesn't have the `isTypeSupported` API.\n\n    if (MediaRecorder.isTypeSupported) {\n      const {\n        restrictions\n      } = this.uppy.opts;\n      let preferredVideoMimeTypes = [];\n\n      if (this.opts.preferredVideoMimeType) {\n        preferredVideoMimeTypes = [this.opts.preferredVideoMimeType];\n      } else if (restrictions.allowedFileTypes) {\n        preferredVideoMimeTypes = restrictions.allowedFileTypes.map(toMimeType).filter(isVideoMimeType);\n      }\n\n      const filterSupportedTypes = candidateType => MediaRecorder.isTypeSupported(candidateType) && getFileTypeExtension(candidateType);\n\n      const acceptableMimeTypes = preferredVideoMimeTypes.filter(filterSupportedTypes);\n\n      if (acceptableMimeTypes.length > 0) {\n        // eslint-disable-next-line prefer-destructuring\n        options.mimeType = acceptableMimeTypes[0];\n      }\n    }\n\n    return options;\n  }\n\n  startRecording() {\n    // only used if supportsMediaRecorder() returned true\n    // eslint-disable-next-line compat/compat\n    this.recorder = new MediaRecorder(this.stream, this.getMediaRecorderOptions());\n    this.recordingChunks = [];\n    let stoppingBecauseOfMaxSize = false;\n    this.recorder.addEventListener('dataavailable', event => {\n      this.recordingChunks.push(event.data);\n      const {\n        restrictions\n      } = this.uppy.opts;\n\n      if (this.recordingChunks.length > 1 && restrictions.maxFileSize != null && !stoppingBecauseOfMaxSize) {\n        const totalSize = this.recordingChunks.reduce((acc, chunk) => acc + chunk.size, 0); // Exclude the initial chunk from the average size calculation because it is likely to be a very small outlier\n\n        const averageChunkSize = (totalSize - this.recordingChunks[0].size) / (this.recordingChunks.length - 1);\n        const expectedEndChunkSize = averageChunkSize * 3;\n        const maxSize = Math.max(0, restrictions.maxFileSize - expectedEndChunkSize);\n\n        if (totalSize > maxSize) {\n          stoppingBecauseOfMaxSize = true;\n          this.uppy.info(this.i18n('recordingStoppedMaxSize'), 'warning', 4000);\n          this.stopRecording();\n        }\n      }\n    }); // use a \"time slice\" of 500ms: ondataavailable will be called each 500ms\n    // smaller time slices mean we can more accurately check the max file size restriction\n\n    this.recorder.start(500);\n\n    if (this.opts.showRecordingLength) {\n      // Start the recordingLengthTimer if we are showing the recording length.\n      this.recordingLengthTimer = setInterval(() => {\n        const currentRecordingLength = this.getPluginState().recordingLengthSeconds;\n        this.setPluginState({\n          recordingLengthSeconds: currentRecordingLength + 1\n        });\n      }, 1000);\n    }\n\n    this.setPluginState({\n      isRecording: true\n    });\n  }\n\n  stopRecording() {\n    const stopped = new Promise(resolve => {\n      this.recorder.addEventListener('stop', () => {\n        resolve();\n      });\n      this.recorder.stop();\n\n      if (this.opts.showRecordingLength) {\n        // Stop the recordingLengthTimer if we are showing the recording length.\n        clearInterval(this.recordingLengthTimer);\n        this.setPluginState({\n          recordingLengthSeconds: 0\n        });\n      }\n    });\n    return stopped.then(() => {\n      this.setPluginState({\n        isRecording: false\n      });\n      return this.getVideo();\n    }).then(file => {\n      try {\n        this.capturedMediaFile = file; // create object url for capture result preview\n\n        this.setPluginState({\n          // eslint-disable-next-line compat/compat\n          recordedVideo: URL.createObjectURL(file.data)\n        });\n        _classPrivateFieldLooseBase(this, _enableMirror)[_enableMirror] = false;\n      } catch (err) {\n        // Logging the error, exept restrictions, which is handled in Core\n        if (!err.isRestriction) {\n          this.uppy.log(err);\n        }\n      }\n    }).then(() => {\n      this.recordingChunks = null;\n      this.recorder = null;\n    }, error => {\n      this.recordingChunks = null;\n      this.recorder = null;\n      throw error;\n    });\n  }\n\n  discardRecordedVideo() {\n    this.setPluginState({\n      recordedVideo: null\n    });\n\n    if (this.opts.mirror) {\n      _classPrivateFieldLooseBase(this, _enableMirror)[_enableMirror] = true;\n    }\n\n    this.capturedMediaFile = null;\n  }\n\n  submit() {\n    try {\n      if (this.capturedMediaFile) {\n        this.uppy.addFile(this.capturedMediaFile);\n      }\n    } catch (err) {\n      // Logging the error, exept restrictions, which is handled in Core\n      if (!err.isRestriction) {\n        this.uppy.log(err, 'error');\n      }\n    }\n  }\n\n  async stop() {\n    if (this.stream) {\n      const audioTracks = this.stream.getAudioTracks();\n      const videoTracks = this.stream.getVideoTracks();\n      audioTracks.concat(videoTracks).forEach(track => track.stop());\n    }\n\n    if (this.recorder) {\n      await new Promise(resolve => {\n        this.recorder.addEventListener('stop', resolve, {\n          once: true\n        });\n        this.recorder.stop();\n\n        if (this.opts.showRecordingLength) {\n          clearInterval(this.recordingLengthTimer);\n        }\n      });\n    }\n\n    this.recordingChunks = null;\n    this.recorder = null;\n    this.webcamActive = false;\n    this.stream = null;\n    this.setPluginState({\n      recordedVideo: null,\n      isRecording: false,\n      recordingLengthSeconds: 0\n    });\n  }\n\n  getVideoElement() {\n    return this.el.querySelector('.uppy-Webcam-video');\n  }\n\n  oneTwoThreeSmile() {\n    return new Promise((resolve, reject) => {\n      let count = this.opts.countdown; // eslint-disable-next-line consistent-return\n\n      const countDown = setInterval(() => {\n        if (!this.webcamActive) {\n          clearInterval(countDown);\n          this.captureInProgress = false;\n          return reject(new Error('Webcam is not active'));\n        }\n\n        if (count > 0) {\n          this.uppy.info(`${count}...`, 'warning', 800);\n          count--;\n        } else {\n          clearInterval(countDown);\n          this.uppy.info(this.i18n('smile'), 'success', 1500);\n          setTimeout(() => resolve(), 1500);\n        }\n      }, 1000);\n    });\n  }\n\n  takeSnapshot() {\n    if (this.captureInProgress) return;\n    this.captureInProgress = true;\n    this.opts.onBeforeSnapshot().catch(err => {\n      const message = typeof err === 'object' ? err.message : err;\n      this.uppy.info(message, 'error', 5000);\n      return Promise.reject(new Error(`onBeforeSnapshot: ${message}`));\n    }).then(() => {\n      return this.getImage();\n    }).then(tagFile => {\n      this.captureInProgress = false;\n\n      try {\n        this.uppy.addFile(tagFile);\n      } catch (err) {\n        // Logging the error, except restrictions, which is handled in Core\n        if (!err.isRestriction) {\n          this.uppy.log(err);\n        }\n      }\n    }, error => {\n      this.captureInProgress = false;\n      throw error;\n    });\n  }\n\n  getImage() {\n    const video = this.getVideoElement();\n\n    if (!video) {\n      return Promise.reject(new Error('No video element found, likely due to the Webcam tab being closed.'));\n    }\n\n    const width = video.videoWidth;\n    const height = video.videoHeight;\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext('2d');\n    ctx.drawImage(video, 0, 0);\n    const {\n      restrictions\n    } = this.uppy.opts;\n    let preferredImageMimeTypes = [];\n\n    if (this.opts.preferredImageMimeType) {\n      preferredImageMimeTypes = [this.opts.preferredImageMimeType];\n    } else if (restrictions.allowedFileTypes) {\n      preferredImageMimeTypes = restrictions.allowedFileTypes.map(toMimeType).filter(isImageMimeType);\n    }\n\n    const mimeType = preferredImageMimeTypes[0] || 'image/jpeg';\n    const ext = getFileTypeExtension(mimeType) || 'jpg';\n    const name = `cam-${Date.now()}.${ext}`;\n    return canvasToBlob(canvas, mimeType).then(blob => {\n      return {\n        source: this.id,\n        name,\n        data: new Blob([blob], {\n          type: mimeType\n        }),\n        type: mimeType\n      };\n    });\n  }\n\n  getVideo() {\n    // Sometimes in iOS Safari, Blobs (especially the first Blob in the recordingChunks Array)\n    // have empty 'type' attributes (e.g. '') so we need to find a Blob that has a defined 'type'\n    // attribute in order to determine the correct MIME type.\n    const mimeType = this.recordingChunks.find(blob => {\n      var _blob$type;\n\n      return ((_blob$type = blob.type) == null ? void 0 : _blob$type.length) > 0;\n    }).type;\n    const fileExtension = getFileTypeExtension(mimeType);\n\n    if (!fileExtension) {\n      return Promise.reject(new Error(`Could not retrieve recording: Unsupported media type \"${mimeType}\"`));\n    }\n\n    const name = `webcam-${Date.now()}.${fileExtension}`;\n    const blob = new Blob(this.recordingChunks, {\n      type: mimeType\n    });\n    const file = {\n      source: this.id,\n      name,\n      data: new Blob([blob], {\n        type: mimeType\n      }),\n      type: mimeType\n    };\n    return Promise.resolve(file);\n  }\n\n  focus() {\n    if (!this.opts.countdown) return;\n    setTimeout(() => {\n      this.uppy.info(this.i18n('smile'), 'success', 1500);\n    }, 1000);\n  }\n\n  changeVideoSource(deviceId) {\n    this.stop();\n    this.start({\n      deviceId\n    });\n  }\n\n  updateVideoSources() {\n    this.mediaDevices.enumerateDevices().then(devices => {\n      this.setPluginState({\n        videoSources: devices.filter(device => device.kind === 'videoinput')\n      });\n    });\n  }\n\n  render() {\n    if (!this.webcamActive) {\n      this.start();\n    }\n\n    const webcamState = this.getPluginState();\n\n    if (!webcamState.cameraReady || !webcamState.hasCamera) {\n      return h(PermissionsScreen, {\n        icon: CameraIcon,\n        i18n: this.i18n,\n        hasCamera: webcamState.hasCamera\n      });\n    }\n\n    return h(CameraScreen // eslint-disable-next-line react/jsx-props-no-spreading\n    , _extends({}, webcamState, {\n      onChangeVideoSource: this.changeVideoSource,\n      onSnapshot: this.takeSnapshot,\n      onStartRecording: this.startRecording,\n      onStopRecording: this.stopRecording,\n      onDiscardRecordedVideo: this.discardRecordedVideo,\n      onSubmit: this.submit,\n      onFocus: this.focus,\n      onStop: this.stop,\n      i18n: this.i18n,\n      modes: this.opts.modes,\n      showRecordingLength: this.opts.showRecordingLength,\n      showVideoSourceDropdown: this.opts.showVideoSourceDropdown,\n      supportsRecording: supportsMediaRecorder(),\n      recording: webcamState.isRecording,\n      mirror: _classPrivateFieldLooseBase(this, _enableMirror)[_enableMirror],\n      src: this.stream\n    }));\n  }\n\n  install() {\n    this.setPluginState({\n      cameraReady: false,\n      recordingLengthSeconds: 0\n    });\n    const {\n      target\n    } = this.opts;\n\n    if (target) {\n      this.mount(target, this);\n    }\n\n    if (this.mediaDevices) {\n      this.updateVideoSources();\n\n      this.mediaDevices.ondevicechange = () => {\n        this.updateVideoSources();\n\n        if (this.stream) {\n          let restartStream = true;\n          const {\n            videoSources,\n            currentDeviceId\n          } = this.getPluginState();\n          videoSources.forEach(videoSource => {\n            if (currentDeviceId === videoSource.deviceId) {\n              restartStream = false;\n            }\n          });\n\n          if (restartStream) {\n            this.stop();\n            this.start();\n          }\n        }\n      };\n    }\n  }\n\n  uninstall() {\n    this.stop();\n    this.unmount();\n  }\n\n  onUnmount() {\n    this.stop();\n  }\n\n}), _class.VERSION = \"2.0.4\", _temp);"]},"metadata":{},"sourceType":"script"}