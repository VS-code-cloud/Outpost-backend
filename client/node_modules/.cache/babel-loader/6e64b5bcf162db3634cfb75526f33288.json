{"ast":null,"code":"\"use strict\";\n\nconst toArray = require('../../../toArray');\n\nconst getRelativePath = require('./getRelativePath');\n\nconst getFilesAndDirectoriesFromDirectory = require('./getFilesAndDirectoriesFromDirectory');\n\nmodule.exports = function webkitGetAsEntryApi(dataTransfer, logDropError) {\n  const files = [];\n  const rootPromises = [];\n  /**\n   * Returns a resolved promise, when :files array is enhanced\n   *\n   * @param {(FileSystemFileEntry|FileSystemDirectoryEntry)} entry\n   * @returns {Promise} - empty promise that resolves when :files is enhanced with a file\n   */\n\n  const createPromiseToAddFileOrParseDirectory = entry => new Promise(resolve => {\n    // This is a base call\n    if (entry.isFile) {\n      // Creates a new File object which can be used to read the file.\n      entry.file(file => {\n        // eslint-disable-next-line no-param-reassign\n        file.relativePath = getRelativePath(entry);\n        files.push(file);\n        resolve();\n      }, // Make sure we resolve on error anyway, it's fine if only one file couldn't be read!\n      error => {\n        logDropError(error);\n        resolve();\n      }); // This is a recursive call\n    } else if (entry.isDirectory) {\n      const directoryReader = entry.createReader();\n      getFilesAndDirectoriesFromDirectory(directoryReader, [], logDropError, {\n        onSuccess: entries => resolve(Promise.all(entries.map(createPromiseToAddFileOrParseDirectory)))\n      });\n    }\n  }); // For each dropped item, - make sure it's a file/directory, and start deepening in!\n\n\n  toArray(dataTransfer.items).forEach(item => {\n    const entry = item.webkitGetAsEntry(); // :entry can be null when we drop the url e.g.\n\n    if (entry) {\n      rootPromises.push(createPromiseToAddFileOrParseDirectory(entry));\n    }\n  });\n  return Promise.all(rootPromises).then(() => files);\n};","map":{"version":3,"sources":["/Users/albertshay/Desktop/silkroad/client/node_modules/@uppy/utils/lib/getDroppedFiles/utils/webkitGetAsEntryApi/index.js"],"names":["toArray","require","getRelativePath","getFilesAndDirectoriesFromDirectory","module","exports","webkitGetAsEntryApi","dataTransfer","logDropError","files","rootPromises","createPromiseToAddFileOrParseDirectory","entry","Promise","resolve","isFile","file","relativePath","push","error","isDirectory","directoryReader","createReader","onSuccess","entries","all","map","items","forEach","item","webkitGetAsEntry","then"],"mappings":"AAAA;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,kBAAD,CAAvB;;AAEA,MAAMC,eAAe,GAAGD,OAAO,CAAC,mBAAD,CAA/B;;AAEA,MAAME,mCAAmC,GAAGF,OAAO,CAAC,uCAAD,CAAnD;;AAEAG,MAAM,CAACC,OAAP,GAAiB,SAASC,mBAAT,CAA6BC,YAA7B,EAA2CC,YAA3C,EAAyD;AACxE,QAAMC,KAAK,GAAG,EAAd;AACA,QAAMC,YAAY,GAAG,EAArB;AACA;AACF;AACA;AACA;AACA;AACA;;AAEE,QAAMC,sCAAsC,GAAGC,KAAK,IAAI,IAAIC,OAAJ,CAAYC,OAAO,IAAI;AAC7E;AACA,QAAIF,KAAK,CAACG,MAAV,EAAkB;AAChB;AACAH,MAAAA,KAAK,CAACI,IAAN,CAAWA,IAAI,IAAI;AACjB;AACAA,QAAAA,IAAI,CAACC,YAAL,GAAoBf,eAAe,CAACU,KAAD,CAAnC;AACAH,QAAAA,KAAK,CAACS,IAAN,CAAWF,IAAX;AACAF,QAAAA,OAAO;AACR,OALD,EAKG;AACHK,MAAAA,KAAK,IAAI;AACPX,QAAAA,YAAY,CAACW,KAAD,CAAZ;AACAL,QAAAA,OAAO;AACR,OATD,EAFgB,CAWZ;AACL,KAZD,MAYO,IAAIF,KAAK,CAACQ,WAAV,EAAuB;AAC5B,YAAMC,eAAe,GAAGT,KAAK,CAACU,YAAN,EAAxB;AACAnB,MAAAA,mCAAmC,CAACkB,eAAD,EAAkB,EAAlB,EAAsBb,YAAtB,EAAoC;AACrEe,QAAAA,SAAS,EAAEC,OAAO,IAAIV,OAAO,CAACD,OAAO,CAACY,GAAR,CAAYD,OAAO,CAACE,GAAR,CAAYf,sCAAZ,CAAZ,CAAD;AADwC,OAApC,CAAnC;AAGD;AACF,GApBuD,CAAxD,CAVwE,CA8BpE;;;AAGJX,EAAAA,OAAO,CAACO,YAAY,CAACoB,KAAd,CAAP,CAA4BC,OAA5B,CAAoCC,IAAI,IAAI;AAC1C,UAAMjB,KAAK,GAAGiB,IAAI,CAACC,gBAAL,EAAd,CAD0C,CACH;;AAEvC,QAAIlB,KAAJ,EAAW;AACTF,MAAAA,YAAY,CAACQ,IAAb,CAAkBP,sCAAsC,CAACC,KAAD,CAAxD;AACD;AACF,GAND;AAOA,SAAOC,OAAO,CAACY,GAAR,CAAYf,YAAZ,EAA0BqB,IAA1B,CAA+B,MAAMtB,KAArC,CAAP;AACD,CAzCD","sourcesContent":["\"use strict\";\n\nconst toArray = require('../../../toArray');\n\nconst getRelativePath = require('./getRelativePath');\n\nconst getFilesAndDirectoriesFromDirectory = require('./getFilesAndDirectoriesFromDirectory');\n\nmodule.exports = function webkitGetAsEntryApi(dataTransfer, logDropError) {\n  const files = [];\n  const rootPromises = [];\n  /**\n   * Returns a resolved promise, when :files array is enhanced\n   *\n   * @param {(FileSystemFileEntry|FileSystemDirectoryEntry)} entry\n   * @returns {Promise} - empty promise that resolves when :files is enhanced with a file\n   */\n\n  const createPromiseToAddFileOrParseDirectory = entry => new Promise(resolve => {\n    // This is a base call\n    if (entry.isFile) {\n      // Creates a new File object which can be used to read the file.\n      entry.file(file => {\n        // eslint-disable-next-line no-param-reassign\n        file.relativePath = getRelativePath(entry);\n        files.push(file);\n        resolve();\n      }, // Make sure we resolve on error anyway, it's fine if only one file couldn't be read!\n      error => {\n        logDropError(error);\n        resolve();\n      }); // This is a recursive call\n    } else if (entry.isDirectory) {\n      const directoryReader = entry.createReader();\n      getFilesAndDirectoriesFromDirectory(directoryReader, [], logDropError, {\n        onSuccess: entries => resolve(Promise.all(entries.map(createPromiseToAddFileOrParseDirectory)))\n      });\n    }\n  }); // For each dropped item, - make sure it's a file/directory, and start deepening in!\n\n\n  toArray(dataTransfer.items).forEach(item => {\n    const entry = item.webkitGetAsEntry(); // :entry can be null when we drop the url e.g.\n\n    if (entry) {\n      rootPromises.push(createPromiseToAddFileOrParseDirectory(entry));\n    }\n  });\n  return Promise.all(rootPromises).then(() => files);\n};"]},"metadata":{},"sourceType":"script"}