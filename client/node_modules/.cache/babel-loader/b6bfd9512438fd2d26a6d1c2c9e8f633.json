{"ast":null,"code":"/* eslint-disable */\n\n/**\n * @source https://github.com/developit/preact-transition-group\n */\n'use strict';\n\nvar _objectWithoutProperties = require(\"/Users/albertshay/Desktop/silkroad/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectWithoutProperties\");\n\nvar _classCallCheck = require(\"/Users/albertshay/Desktop/silkroad/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/albertshay/Desktop/silkroad/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/albertshay/Desktop/silkroad/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/albertshay/Desktop/silkroad/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/albertshay/Desktop/silkroad/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _excluded = [\"childFactory\", \"transitionLeave\", \"transitionName\", \"transitionAppear\", \"transitionEnter\", \"transitionLeaveTimeout\", \"transitionEnterTimeout\", \"transitionAppearTimeout\", \"component\"];\n\nvar _require = require('preact'),\n    Component = _require.Component,\n    cloneElement = _require.cloneElement,\n    h = _require.h,\n    toChildArray = _require.toChildArray;\n\nfunction assign(obj, props) {\n  return Object.assign(obj, props);\n}\n\nfunction getKey(vnode, fallback) {\n  var _vnode$key;\n\n  return (_vnode$key = vnode == null ? void 0 : vnode.key) != null ? _vnode$key : fallback;\n}\n\nfunction linkRef(component, name) {\n  var cache = component._ptgLinkedRefs || (component._ptgLinkedRefs = {});\n  return cache[name] || (cache[name] = function (c) {\n    component.refs[name] = c;\n  });\n}\n\nfunction getChildMapping(children) {\n  var out = {};\n\n  for (var i = 0; i < children.length; i++) {\n    if (children[i] != null) {\n      var key = getKey(children[i], i.toString(36));\n      out[key] = children[i];\n    }\n  }\n\n  return out;\n}\n\nfunction mergeChildMappings(prev, next) {\n  prev = prev || {};\n  next = next || {};\n\n  var getValueForKey = function getValueForKey(key) {\n    return next.hasOwnProperty(key) ? next[key] : prev[key];\n  }; // For each key of `next`, the list of keys to insert before that key in\n  // the combined list\n\n\n  var nextKeysPending = {};\n  var pendingKeys = [];\n\n  for (var prevKey in prev) {\n    if (next.hasOwnProperty(prevKey)) {\n      if (pendingKeys.length) {\n        nextKeysPending[prevKey] = pendingKeys;\n        pendingKeys = [];\n      }\n    } else {\n      pendingKeys.push(prevKey);\n    }\n  }\n\n  var childMapping = {};\n\n  for (var nextKey in next) {\n    if (nextKeysPending.hasOwnProperty(nextKey)) {\n      for (var i = 0; i < nextKeysPending[nextKey].length; i++) {\n        var pendingNextKey = nextKeysPending[nextKey][i];\n        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);\n      }\n    }\n\n    childMapping[nextKey] = getValueForKey(nextKey);\n  } // Finally, add the keys which didn't appear before any key in `next`\n\n\n  for (var _i = 0; _i < pendingKeys.length; _i++) {\n    childMapping[pendingKeys[_i]] = getValueForKey(pendingKeys[_i]);\n  }\n\n  return childMapping;\n}\n\nvar identity = function identity(i) {\n  return i;\n};\n\nvar TransitionGroup = /*#__PURE__*/function (_Component) {\n  _inherits(TransitionGroup, _Component);\n\n  var _super = _createSuper(TransitionGroup);\n\n  function TransitionGroup(props, context) {\n    var _this;\n\n    _classCallCheck(this, TransitionGroup);\n\n    _this = _super.call(this, props, context);\n    _this.refs = {};\n    _this.state = {\n      children: getChildMapping(toChildArray(toChildArray(_this.props.children)) || [])\n    };\n    _this.performAppear = _this.performAppear.bind(_assertThisInitialized(_this));\n    _this.performEnter = _this.performEnter.bind(_assertThisInitialized(_this));\n    _this.performLeave = _this.performLeave.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(TransitionGroup, [{\n    key: \"componentWillMount\",\n    value: function componentWillMount() {\n      this.currentlyTransitioningKeys = {};\n      this.keysToAbortLeave = [];\n      this.keysToEnter = [];\n      this.keysToLeave = [];\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var initialChildMapping = this.state.children;\n\n      for (var key in initialChildMapping) {\n        if (initialChildMapping[key]) {\n          // this.performAppear(getKey(initialChildMapping[key], key));\n          this.performAppear(key);\n        }\n      }\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      var nextChildMapping = getChildMapping(toChildArray(nextProps.children) || []);\n      var prevChildMapping = this.state.children;\n      this.setState(function (prevState) {\n        return {\n          children: mergeChildMappings(prevState.children, nextChildMapping)\n        };\n      });\n      var key;\n\n      for (key in nextChildMapping) {\n        if (nextChildMapping.hasOwnProperty(key)) {\n          var hasPrev = prevChildMapping && prevChildMapping.hasOwnProperty(key); // We should re-enter the component and abort its leave function\n\n          if (nextChildMapping[key] && hasPrev && this.currentlyTransitioningKeys[key]) {\n            this.keysToEnter.push(key);\n            this.keysToAbortLeave.push(key);\n          } else if (nextChildMapping[key] && !hasPrev && !this.currentlyTransitioningKeys[key]) {\n            this.keysToEnter.push(key);\n          }\n        }\n      }\n\n      for (key in prevChildMapping) {\n        if (prevChildMapping.hasOwnProperty(key)) {\n          var hasNext = nextChildMapping && nextChildMapping.hasOwnProperty(key);\n\n          if (prevChildMapping[key] && !hasNext && !this.currentlyTransitioningKeys[key]) {\n            this.keysToLeave.push(key);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      var keysToEnter = this.keysToEnter;\n      this.keysToEnter = [];\n      keysToEnter.forEach(this.performEnter);\n      var keysToLeave = this.keysToLeave;\n      this.keysToLeave = [];\n      keysToLeave.forEach(this.performLeave);\n    }\n  }, {\n    key: \"_finishAbort\",\n    value: function _finishAbort(key) {\n      var idx = this.keysToAbortLeave.indexOf(key);\n\n      if (idx !== -1) {\n        this.keysToAbortLeave.splice(idx, 1);\n      }\n    }\n  }, {\n    key: \"performAppear\",\n    value: function performAppear(key) {\n      this.currentlyTransitioningKeys[key] = true;\n      var component = this.refs[key];\n\n      if (component.componentWillAppear) {\n        component.componentWillAppear(this._handleDoneAppearing.bind(this, key));\n      } else {\n        this._handleDoneAppearing(key);\n      }\n    }\n  }, {\n    key: \"_handleDoneAppearing\",\n    value: function _handleDoneAppearing(key) {\n      var component = this.refs[key];\n\n      if (component.componentDidAppear) {\n        component.componentDidAppear();\n      }\n\n      delete this.currentlyTransitioningKeys[key];\n\n      this._finishAbort(key);\n\n      var currentChildMapping = getChildMapping(toChildArray(this.props.children) || []);\n\n      if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {\n        // This was removed before it had fully appeared. Remove it.\n        this.performLeave(key);\n      }\n    }\n  }, {\n    key: \"performEnter\",\n    value: function performEnter(key) {\n      this.currentlyTransitioningKeys[key] = true;\n      var component = this.refs[key];\n\n      if (component.componentWillEnter) {\n        component.componentWillEnter(this._handleDoneEntering.bind(this, key));\n      } else {\n        this._handleDoneEntering(key);\n      }\n    }\n  }, {\n    key: \"_handleDoneEntering\",\n    value: function _handleDoneEntering(key) {\n      var component = this.refs[key];\n\n      if (component.componentDidEnter) {\n        component.componentDidEnter();\n      }\n\n      delete this.currentlyTransitioningKeys[key];\n\n      this._finishAbort(key);\n\n      var currentChildMapping = getChildMapping(toChildArray(this.props.children) || []);\n\n      if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {\n        // This was removed before it had fully entered. Remove it.\n        this.performLeave(key);\n      }\n    }\n  }, {\n    key: \"performLeave\",\n    value: function performLeave(key) {\n      // If we should immediately abort this leave function,\n      // don't run the leave transition at all.\n      var idx = this.keysToAbortLeave.indexOf(key);\n\n      if (idx !== -1) {\n        return;\n      }\n\n      this.currentlyTransitioningKeys[key] = true;\n      var component = this.refs[key];\n\n      if (component.componentWillLeave) {\n        component.componentWillLeave(this._handleDoneLeaving.bind(this, key));\n      } else {\n        // Note that this is somewhat dangerous b/c it calls setState()\n        // again, effectively mutating the component before all the work\n        // is done.\n        this._handleDoneLeaving(key);\n      }\n    }\n  }, {\n    key: \"_handleDoneLeaving\",\n    value: function _handleDoneLeaving(key) {\n      // If we should immediately abort the leave,\n      // then skip this altogether\n      var idx = this.keysToAbortLeave.indexOf(key);\n\n      if (idx !== -1) {\n        return;\n      }\n\n      var component = this.refs[key];\n\n      if (component.componentDidLeave) {\n        component.componentDidLeave();\n      }\n\n      delete this.currentlyTransitioningKeys[key];\n      var currentChildMapping = getChildMapping(toChildArray(this.props.children) || []);\n\n      if (currentChildMapping && currentChildMapping.hasOwnProperty(key)) {\n        // This entered again before it fully left. Add it again.\n        this.performEnter(key);\n      } else {\n        var children = assign({}, this.state.children);\n        delete children[key];\n        this.setState({\n          children: children\n        });\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render(_ref, _ref2) {\n      var childFactory = _ref.childFactory,\n          transitionLeave = _ref.transitionLeave,\n          transitionName = _ref.transitionName,\n          transitionAppear = _ref.transitionAppear,\n          transitionEnter = _ref.transitionEnter,\n          transitionLeaveTimeout = _ref.transitionLeaveTimeout,\n          transitionEnterTimeout = _ref.transitionEnterTimeout,\n          transitionAppearTimeout = _ref.transitionAppearTimeout,\n          component = _ref.component,\n          props = _objectWithoutProperties(_ref, _excluded);\n\n      var children = _ref2.children;\n      // TODO: we could get rid of the need for the wrapper node\n      // by cloning a single child\n      var childrenToRender = [];\n\n      for (var key in children) {\n        if (children.hasOwnProperty(key)) {\n          var child = children[key];\n\n          if (child) {\n            var ref = linkRef(this, key),\n                el = cloneElement(childFactory(child), {\n              ref: ref,\n              key: key\n            });\n            childrenToRender.push(el);\n          }\n        }\n      }\n\n      return h(component, props, childrenToRender);\n    }\n  }]);\n\n  return TransitionGroup;\n}(Component);\n\nTransitionGroup.defaultProps = {\n  component: 'span',\n  childFactory: identity\n};\nmodule.exports = TransitionGroup;","map":{"version":3,"sources":["/Users/albertshay/Desktop/silkroad/client/node_modules/@uppy/informer/lib/TransitionGroup.js"],"names":["require","Component","cloneElement","h","toChildArray","assign","obj","props","Object","getKey","vnode","fallback","_vnode$key","key","linkRef","component","name","cache","_ptgLinkedRefs","c","refs","getChildMapping","children","out","i","length","toString","mergeChildMappings","prev","next","getValueForKey","hasOwnProperty","nextKeysPending","pendingKeys","prevKey","push","childMapping","nextKey","pendingNextKey","identity","TransitionGroup","context","state","performAppear","bind","performEnter","performLeave","currentlyTransitioningKeys","keysToAbortLeave","keysToEnter","keysToLeave","initialChildMapping","nextProps","nextChildMapping","prevChildMapping","setState","prevState","hasPrev","hasNext","forEach","idx","indexOf","splice","componentWillAppear","_handleDoneAppearing","componentDidAppear","_finishAbort","currentChildMapping","componentWillEnter","_handleDoneEntering","componentDidEnter","componentWillLeave","_handleDoneLeaving","componentDidLeave","childFactory","transitionLeave","transitionName","transitionAppear","transitionEnter","transitionLeaveTimeout","transitionEnterTimeout","transitionAppearTimeout","childrenToRender","child","ref","el","defaultProps","module","exports"],"mappings":"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","sourcesContent":["/* eslint-disable */\n\n/**\n * @source https://github.com/developit/preact-transition-group\n */\n'use strict';\n\nconst {\n  Component,\n  cloneElement,\n  h,\n  toChildArray\n} = require('preact');\n\nfunction assign(obj, props) {\n  return Object.assign(obj, props);\n}\n\nfunction getKey(vnode, fallback) {\n  var _vnode$key;\n\n  return (_vnode$key = vnode == null ? void 0 : vnode.key) != null ? _vnode$key : fallback;\n}\n\nfunction linkRef(component, name) {\n  const cache = component._ptgLinkedRefs || (component._ptgLinkedRefs = {});\n  return cache[name] || (cache[name] = c => {\n    component.refs[name] = c;\n  });\n}\n\nfunction getChildMapping(children) {\n  const out = {};\n\n  for (let i = 0; i < children.length; i++) {\n    if (children[i] != null) {\n      const key = getKey(children[i], i.toString(36));\n      out[key] = children[i];\n    }\n  }\n\n  return out;\n}\n\nfunction mergeChildMappings(prev, next) {\n  prev = prev || {};\n  next = next || {};\n\n  const getValueForKey = key => next.hasOwnProperty(key) ? next[key] : prev[key]; // For each key of `next`, the list of keys to insert before that key in\n  // the combined list\n\n\n  const nextKeysPending = {};\n  let pendingKeys = [];\n\n  for (const prevKey in prev) {\n    if (next.hasOwnProperty(prevKey)) {\n      if (pendingKeys.length) {\n        nextKeysPending[prevKey] = pendingKeys;\n        pendingKeys = [];\n      }\n    } else {\n      pendingKeys.push(prevKey);\n    }\n  }\n\n  const childMapping = {};\n\n  for (const nextKey in next) {\n    if (nextKeysPending.hasOwnProperty(nextKey)) {\n      for (let i = 0; i < nextKeysPending[nextKey].length; i++) {\n        const pendingNextKey = nextKeysPending[nextKey][i];\n        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);\n      }\n    }\n\n    childMapping[nextKey] = getValueForKey(nextKey);\n  } // Finally, add the keys which didn't appear before any key in `next`\n\n\n  for (let i = 0; i < pendingKeys.length; i++) {\n    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);\n  }\n\n  return childMapping;\n}\n\nconst identity = i => i;\n\nclass TransitionGroup extends Component {\n  constructor(props, context) {\n    super(props, context);\n    this.refs = {};\n    this.state = {\n      children: getChildMapping(toChildArray(toChildArray(this.props.children)) || [])\n    };\n    this.performAppear = this.performAppear.bind(this);\n    this.performEnter = this.performEnter.bind(this);\n    this.performLeave = this.performLeave.bind(this);\n  }\n\n  componentWillMount() {\n    this.currentlyTransitioningKeys = {};\n    this.keysToAbortLeave = [];\n    this.keysToEnter = [];\n    this.keysToLeave = [];\n  }\n\n  componentDidMount() {\n    const initialChildMapping = this.state.children;\n\n    for (const key in initialChildMapping) {\n      if (initialChildMapping[key]) {\n        // this.performAppear(getKey(initialChildMapping[key], key));\n        this.performAppear(key);\n      }\n    }\n  }\n\n  componentWillReceiveProps(nextProps) {\n    const nextChildMapping = getChildMapping(toChildArray(nextProps.children) || []);\n    const prevChildMapping = this.state.children;\n    this.setState(prevState => ({\n      children: mergeChildMappings(prevState.children, nextChildMapping)\n    }));\n    let key;\n\n    for (key in nextChildMapping) {\n      if (nextChildMapping.hasOwnProperty(key)) {\n        const hasPrev = prevChildMapping && prevChildMapping.hasOwnProperty(key); // We should re-enter the component and abort its leave function\n\n        if (nextChildMapping[key] && hasPrev && this.currentlyTransitioningKeys[key]) {\n          this.keysToEnter.push(key);\n          this.keysToAbortLeave.push(key);\n        } else if (nextChildMapping[key] && !hasPrev && !this.currentlyTransitioningKeys[key]) {\n          this.keysToEnter.push(key);\n        }\n      }\n    }\n\n    for (key in prevChildMapping) {\n      if (prevChildMapping.hasOwnProperty(key)) {\n        const hasNext = nextChildMapping && nextChildMapping.hasOwnProperty(key);\n\n        if (prevChildMapping[key] && !hasNext && !this.currentlyTransitioningKeys[key]) {\n          this.keysToLeave.push(key);\n        }\n      }\n    }\n  }\n\n  componentDidUpdate() {\n    const {\n      keysToEnter\n    } = this;\n    this.keysToEnter = [];\n    keysToEnter.forEach(this.performEnter);\n    const {\n      keysToLeave\n    } = this;\n    this.keysToLeave = [];\n    keysToLeave.forEach(this.performLeave);\n  }\n\n  _finishAbort(key) {\n    const idx = this.keysToAbortLeave.indexOf(key);\n\n    if (idx !== -1) {\n      this.keysToAbortLeave.splice(idx, 1);\n    }\n  }\n\n  performAppear(key) {\n    this.currentlyTransitioningKeys[key] = true;\n    const component = this.refs[key];\n\n    if (component.componentWillAppear) {\n      component.componentWillAppear(this._handleDoneAppearing.bind(this, key));\n    } else {\n      this._handleDoneAppearing(key);\n    }\n  }\n\n  _handleDoneAppearing(key) {\n    const component = this.refs[key];\n\n    if (component.componentDidAppear) {\n      component.componentDidAppear();\n    }\n\n    delete this.currentlyTransitioningKeys[key];\n\n    this._finishAbort(key);\n\n    const currentChildMapping = getChildMapping(toChildArray(this.props.children) || []);\n\n    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {\n      // This was removed before it had fully appeared. Remove it.\n      this.performLeave(key);\n    }\n  }\n\n  performEnter(key) {\n    this.currentlyTransitioningKeys[key] = true;\n    const component = this.refs[key];\n\n    if (component.componentWillEnter) {\n      component.componentWillEnter(this._handleDoneEntering.bind(this, key));\n    } else {\n      this._handleDoneEntering(key);\n    }\n  }\n\n  _handleDoneEntering(key) {\n    const component = this.refs[key];\n\n    if (component.componentDidEnter) {\n      component.componentDidEnter();\n    }\n\n    delete this.currentlyTransitioningKeys[key];\n\n    this._finishAbort(key);\n\n    const currentChildMapping = getChildMapping(toChildArray(this.props.children) || []);\n\n    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {\n      // This was removed before it had fully entered. Remove it.\n      this.performLeave(key);\n    }\n  }\n\n  performLeave(key) {\n    // If we should immediately abort this leave function,\n    // don't run the leave transition at all.\n    const idx = this.keysToAbortLeave.indexOf(key);\n\n    if (idx !== -1) {\n      return;\n    }\n\n    this.currentlyTransitioningKeys[key] = true;\n    const component = this.refs[key];\n\n    if (component.componentWillLeave) {\n      component.componentWillLeave(this._handleDoneLeaving.bind(this, key));\n    } else {\n      // Note that this is somewhat dangerous b/c it calls setState()\n      // again, effectively mutating the component before all the work\n      // is done.\n      this._handleDoneLeaving(key);\n    }\n  }\n\n  _handleDoneLeaving(key) {\n    // If we should immediately abort the leave,\n    // then skip this altogether\n    const idx = this.keysToAbortLeave.indexOf(key);\n\n    if (idx !== -1) {\n      return;\n    }\n\n    const component = this.refs[key];\n\n    if (component.componentDidLeave) {\n      component.componentDidLeave();\n    }\n\n    delete this.currentlyTransitioningKeys[key];\n    const currentChildMapping = getChildMapping(toChildArray(this.props.children) || []);\n\n    if (currentChildMapping && currentChildMapping.hasOwnProperty(key)) {\n      // This entered again before it fully left. Add it again.\n      this.performEnter(key);\n    } else {\n      const children = assign({}, this.state.children);\n      delete children[key];\n      this.setState({\n        children\n      });\n    }\n  }\n\n  render({\n    childFactory,\n    transitionLeave,\n    transitionName,\n    transitionAppear,\n    transitionEnter,\n    transitionLeaveTimeout,\n    transitionEnterTimeout,\n    transitionAppearTimeout,\n    component,\n    ...props\n  }, {\n    children\n  }) {\n    // TODO: we could get rid of the need for the wrapper node\n    // by cloning a single child\n    const childrenToRender = [];\n\n    for (const key in children) {\n      if (children.hasOwnProperty(key)) {\n        const child = children[key];\n\n        if (child) {\n          const ref = linkRef(this, key),\n                el = cloneElement(childFactory(child), {\n            ref,\n            key\n          });\n          childrenToRender.push(el);\n        }\n      }\n    }\n\n    return h(component, props, childrenToRender);\n  }\n\n}\n\nTransitionGroup.defaultProps = {\n  component: 'span',\n  childFactory: identity\n};\nmodule.exports = TransitionGroup;"]},"metadata":{},"sourceType":"script"}